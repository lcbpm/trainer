# 5. 数据库

## 目录
- [5.1 MySQL 优化](#51-mysql-优化)
  - [5.1.1 索引最左匹配原理](#511-索引最左匹配原理)
  - [5.1.2 组合索引设计与优化](#512-组合索引设计与优化)
  - [5.1.3 索引下推原理与应用](#513-索引下推原理与应用)
  - [5.1.4 Filesort优化策略](#514-filesort优化策略)
- [5.2 事务机制](#52-事务机制)
- [5.3 连接池](#53-连接池)
- [5.4 MySQL 主从同步原理](#54-mysql-主从同步原理)
  - [5.4.1 主从同步基本概念](#541-主从同步基本概念)
    - [Q: 什么是 MySQL 主从同步？](#q-什么是-mysql-主从同步)
  - [5.4.2 主从同步核心原理](#542-主从同步核心原理)
    - [Q: MySQL 主从同步的核心工作原理？](#q-mysql-主从同步的核心工作原理)
  - [5.4.3 主从同步的三种方式](#543-主从同步的三种方式)
    - [Q: MySQL 主从同步有哪几种方式？有什么区别？](#q-mysql-主从同步有哪几种方式有什么区别)
  - [5.4.4 主从同步模式](#544-主从同步模式)
    - [Q: MySQL 主从同步有哪些模式？](#q-mysql-主从同步有哪些模式)
  - [5.4.5 主从同步配置](#545-主从同步配置)
    - [Q: 如何配置 MySQL 主从同步？](#q-如何配置-mysql-主从同步)
  - [5.4.6 主从同步优化](#546-主从同步优化)
    - [Q: 如何优化 MySQL 主从同步？](#q-如何优化-mysql-主从同步)
- [5.5 MVCC机制](#55-mvcc机制)
  - [Q: 什么是MVCC（多版本并发控制）？](#q-什么是mvcc多版本并发控制)

---

## 5.1 MySQL 优化

**Q: SQL查询优化策略？**
- 创建合适的索引（B+树结构）
- 避免SELECT *，只查询需要的字段
- 使用LIMIT限制返回行数
- 避免在WHERE子句中使用函数
- 合理使用JOIN，小表驱动大表

**Q: 索引的类型和使用场景？**
- **主键索引**：唯一且非空
- **唯一索引**：值唯一但可为空
- **普通索引**：提高查询效率
- **组合索引**：多列组合，注意最左前缀原则
- **覆盖索引**：索引包含所需字段，避免回表

### 5.1.1 索引最左匹配原理

**Q: 组合索引的最左匹配原理是什么？**

最左匹配原理是MySQL组合索引的核心规则：**必须从最左边的列开始，连续使用索引列，不能跳过**。

#### 最左匹配的基本规则

```sql
-- 假设有表和组合索引
CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(50),      -- 列a
    age INT,               -- 列b
    city VARCHAR(50),      -- 列c
    email VARCHAR(100)
);

-- 创建组合索引
CREATE INDEX idx_name_age_city ON users (name, age, city);
```

#### ✅ 会走索引的情况

```sql
-- 1. 单独使用最左列
SELECT * FROM users WHERE name = 'John';
-- 走索引：使用了最左列 name

-- 2. 从左开始的连续组合
SELECT * FROM users WHERE name = 'John' AND age = 25;
-- 走索引：name + age

SELECT * FROM users WHERE name = 'John' AND age = 25 AND city = 'Beijing';
-- 走索引：name + age + city

-- 3. 包含最左列的任意组合（顺序无关）
SELECT * FROM users WHERE city = 'Beijing' AND name = 'John' AND age = 25;
-- 走索引：MySQL优化器重排为 name + age + city

SELECT * FROM users WHERE name = 'John' AND city = 'Beijing';
-- 走索引：但只有name列有效，city列无法使用（跳过了age）

SELECT * FROM users WHERE age = 25 AND name = 'John';
-- 走索引：MySQL优化器重排为 name + age

-- 4. 范围查询组合
SELECT * FROM users WHERE name = 'John' AND age > 25;
-- 走索引：name等值 + age范围

SELECT * FROM users WHERE name > 'A' AND name < 'M';
-- 走索引：name范围查询

SELECT * FROM users WHERE name = 'John' AND age > 25 AND city = 'Beijing';
-- 走索引：name等值 + age范围 + city索引下推
```

#### ❌ 不会走索引的情况

```sql
-- 1. 不包含最左列的查询
SELECT * FROM users WHERE age = 25;
-- 不走索引：跳过了最左列 name

SELECT * FROM users WHERE city = 'Beijing';
-- 不走索引：跳过了最左列 name

SELECT * FROM users WHERE age = 25 AND city = 'Beijing';
-- 不走索引：跳过了最左列 name

SELECT * FROM users WHERE city = 'Beijing' AND age = 25;
-- 不走索引：跳过了最左列 name
```

#### 最左匹配的底层原理

```sql
/*
组合索引 idx_name_age_city (name, age, city) 的存储结构类似：

('Alice', 20, 'Beijing')    → Row1
('Alice', 25, 'Shanghai')   → Row2
('Bob', 30, 'Beijing')      → Row3
('Bob', 35, 'Shanghai')     → Row4
('John', 25, 'Beijing')     → Row5
('John', 30, 'Shanghai')    → Row6

索引是按 name → age → city 的顺序排列的
*/

-- 为什么必须从最左开始？
/*
1. 如果查询 WHERE age = 25：
   - 索引中age=25的记录：Row2, Row5
   - 但它们在索引中不连续！
   - 必须扫描整个索引才能找到，效率低下

2. 如果查询 WHERE name = 'John'：
   - 索引中name='John'的记录：Row5, Row6
   - 它们在索引中是连续的！
   - 可以快速定位和范围扫描

3. 如果查询 WHERE name = 'John' AND age = 25：
   - 先定位name='John'：Row5, Row6
   - 再在这个范围内查找age=25：Row5
   - 高效的二级过滤
*/
```

#### 执行计划验证

```sql
-- 创建测试表和索引
CREATE TABLE test_leftmost (
    id INT PRIMARY KEY,
    a INT,
    b INT,
    c INT
);

CREATE INDEX idx_abc ON test_leftmost (a, b, c);

-- 测试各种情况
-- 1. ✅ 单独使用a
EXPLAIN SELECT * FROM test_leftmost WHERE a = 1;
-- type: ref, key: idx_abc, key_len: 5

-- 2. ✅ 使用a,b
EXPLAIN SELECT * FROM test_leftmost WHERE a = 1 AND b = 2;
-- type: ref, key: idx_abc, key_len: 10

-- 3. ✅ 使用a,b,c
EXPLAIN SELECT * FROM test_leftmost WHERE a = 1 AND b = 2 AND c = 3;
-- type: ref, key: idx_abc, key_len: 15

-- 4. ✅ 顺序无关：c,b,a
EXPLAIN SELECT * FROM test_leftmost WHERE c = 3 AND b = 2 AND a = 1;
-- type: ref, key: idx_abc, key_len: 15 (优化器重排)

-- 5. ✅ 跳过中间列：a,c
EXPLAIN SELECT * FROM test_leftmost WHERE a = 1 AND c = 3;
-- type: ref, key: idx_abc, key_len: 5 (只有a列有效)

-- 6. ❌ 不包含最左列：b
EXPLAIN SELECT * FROM test_leftmost WHERE b = 2;
-- type: ALL, key: NULL (全表扫描)

-- 7. ❌ 不包含最左列：c
EXPLAIN SELECT * FROM test_leftmost WHERE c = 3;
-- type: ALL, key: NULL (全表扫描)

-- 8. ❌ 不包含最左列：b,c
EXPLAIN SELECT * FROM test_leftmost WHERE b = 2 AND c = 3;
-- type: ALL, key: NULL (全表扫描)
```

#### 特殊情况：范围查询的影响

```sql
-- 范围查询会"截断"索引的使用
CREATE INDEX idx_name_age_city ON users (name, age, city);

-- 查询1：范围查询后的列无法用于精确匹配
SELECT * FROM users 
WHERE name = 'John' AND age > 25 AND city = 'Beijing';
/*
索引使用情况：
- name = 'John': 走索引（等值）
- age > 25: 走索引（范围）
- city = 'Beijing': 不能走索引精确匹配，但可以索引下推过滤
*/

-- 查询2：调整索引顺序优化
CREATE INDEX idx_name_city_age ON users (name, city, age);

SELECT * FROM users 
WHERE name = 'John' AND city = 'Beijing' AND age > 25;
/*
现在索引使用更充分：
- name = 'John': 走索引（等值）
- city = 'Beijing': 走索引（等值）
- age > 25: 走索引（范围）
*/
```

#### 实际应用中的索引设计

```sql
-- 根据查询模式设计索引
-- 如果经常有这些查询：
-- 1. WHERE name = ?
-- 2. WHERE name = ? AND age = ?
-- 3. WHERE name = ? AND age = ? AND city = ?
-- 4. WHERE name = ? AND city = ?

-- 那么创建索引：
CREATE INDEX idx_name_age_city ON users (name, age, city);
-- 支持查询1,2,3,4（查询4中 city 无法精确匹配，但可以过滤）

-- 如果还经常有这个查询：
-- WHERE age = ? AND city = ?

-- 需要额外创建索引：
CREATE INDEX idx_age_city ON users (age, city);
-- 因为原索引无法支持跳过name的查询
```

#### 总结：最左匹配规则

**会走索引的情况：**
- a
- ab
- abc
- ac（只有a有效）
- ca（优化器重排，只有a有效）
- ba（优化器重排为ab）
- cba（优化器重排为abc）
- 任何包含a的组合

**不会走索引的情况：**
- b
- c  
- bc
- cb
- 任何不包含a的组合

**关键原则：**
1. **必须包含最左列**：查询条件中必须包含组合索引的最左列
2. **连续性优先**：从最左列开始的连续列能被有效使用
3. **顺序无关**：WHERE条件的顺序不影响索引使用，MySQL优化器会重排
4. **范围截断**：范围查询会影响后续列的精确匹配，但不影响索引下推

### 5.1.2 组合索引设计与优化

**Q: 如何设计高效的组合索引？**

组合索引（复合索引）是数据库性能优化的关键技术，合理的设计可以显著提高查询效率。

#### 组合索引设计原则

```sql
-- 组合索引设计的黄金法则：等值查询 > 范围查询 > 排序字段

-- 示例表结构
CREATE TABLE orders (
    id INT PRIMARY KEY,
    user_id INT,
    order_date DATE,
    status VARCHAR(20),
    amount DECIMAL(10,2),
    category_id INT,
    created_at TIMESTAMP
);

-- 常见查询模式分析
-- 查询1：用户的特定状态订单
SELECT * FROM orders WHERE user_id = 123 AND status = 'completed';

-- 查询2：时间范围内的订单
SELECT * FROM orders WHERE order_date >= '2023-01-01' AND order_date <= '2023-12-31';

-- 查询3：多条件组合查询
SELECT * FROM orders 
WHERE user_id = 123 
  AND order_date >= '2023-01-01' 
  AND status = 'completed' 
ORDER BY created_at DESC;
```

#### 索引设计策略

```sql
-- 策略1：按查询频率设计
-- 高频查询：用户ID + 状态
CREATE INDEX idx_user_status ON orders (user_id, status);
-- 支持：WHERE user_id = ? AND status = ?

-- 中频查询：时间范围 + 状态
CREATE INDEX idx_date_status ON orders (order_date, status);
-- 支持：WHERE order_date >= ? AND order_date <= ? AND status = ?

-- 策略2：按数据区分度设计（高区分度在前）
CREATE INDEX idx_optimized ON orders (
    user_id,     -- 高区分度：100万用户
    order_date,  -- 中区分度：按日期分布
    status       -- 低区分度：只有3-5个状态值
);

-- 策略3：覆盖索引设计（避免回表）
CREATE INDEX idx_covering ON orders (
    user_id, 
    status, 
    order_date,
    amount      -- 包含常用查询字段
);

-- 这个查询不会回表
SELECT user_id, status, order_date, amount 
FROM orders 
WHERE user_id = 123 AND status = 'completed';
```

#### 实际优化案例

```sql
-- 案例：电商订单系统索引优化
-- 原始表结构
CREATE TABLE ecommerce_orders (
    order_id BIGINT PRIMARY KEY,
    user_id INT,
    merchant_id INT,
    product_id INT,
    order_status TINYINT,  -- 1:待付款 2:已付款 3:已发货 4:已完成
    order_amount DECIMAL(10,2),
    order_time DATETIME,
    pay_time DATETIME,
    delivery_time DATETIME,
    province_id SMALLINT,
    city_id INT
);

-- 业务查询场景分析
-- 场景1：用户查看自己的订单（高频）
SELECT * FROM ecommerce_orders 
WHERE user_id = 12345 
ORDER BY order_time DESC 
LIMIT 10;

-- 场景2：商家查看订单（高频）
SELECT * FROM ecommerce_orders 
WHERE merchant_id = 999 AND order_status = 2
ORDER BY order_time DESC;

-- 场景3：运营的数据统计（中频）
SELECT COUNT(*), SUM(order_amount) 
FROM ecommerce_orders 
WHERE order_time >= '2023-01-01' 
  AND order_time < '2023-02-01' 
  AND order_status = 4;

-- 场景4：地区分析（低频）
SELECT province_id, COUNT(*), AVG(order_amount)
FROM ecommerce_orders 
WHERE order_time >= '2023-01-01'
  AND order_status = 4
GROUP BY province_id;

-- 优化后的索引设计
-- 索引1：支持用户查询（高频）
CREATE INDEX idx_user_time ON ecommerce_orders (user_id, order_time);

-- 索引2：支持商家查询（高频）
CREATE INDEX idx_merchant_status_time ON ecommerce_orders (merchant_id, order_status, order_time);

-- 索引3：支持时间范围统计（中频）
CREATE INDEX idx_time_status_amount ON ecommerce_orders (order_time, order_status, order_amount);

-- 索引4：支持地区分析（低频）
CREATE INDEX idx_time_status_province ON ecommerce_orders (order_time, order_status, province_id);
```

#### 组合索引的高级优化技巧

```sql
-- 技巧1：前缀压缩优化
-- 对于长字符串字段，使用前缀索引
CREATE INDEX idx_product_name_prefix ON products (name(10), category_id);
-- 只索引商品名称的前10个字符

-- 技巧2：函数索引替代方案（MySQL 5.7）
-- 不能直接创建函数索引，但可以用生成列
ALTER TABLE orders 
ADD COLUMN order_year_month INT GENERATED ALWAYS AS (YEAR(order_time) * 100 + MONTH(order_time)) STORED;

CREATE INDEX idx_year_month_status ON orders (order_year_month, order_status);

-- 技巧3：部分索引（有条件索引）
-- MySQL不支持，但可以通过设计模拟
CREATE INDEX idx_active_users ON orders (user_id, order_time) 
WHERE order_status IN (1,2,3);  -- 仅为演示，MySQL不支持
```

### 5.1.3 索引下推原理与应用

**Q: 索引下推（Index Condition Pushdown, ICP）是什么？**

索引下推是MySQL 5.6引入的优化技术，它将部分WHERE条件的过滤操作下推到存储引擎层，在读取索引时就进行过滤，从而减少回表次数。

#### 索引下推的工作原理

```sql
-- 示例表结构
CREATE TABLE employees (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    age INT,
    department VARCHAR(30),
    salary DECIMAL(10,2),
    hire_date DATE
);

-- 创建组合索引
CREATE INDEX idx_name_age_dept ON employees (name, age, department);

-- 查询示例
SELECT * FROM employees 
WHERE name LIKE 'John%' 
  AND age > 30 
  AND department = 'IT';
```

**不使用索引下推的情况：**
```
1. MySQL Server根据索引找到name LIKE 'John%'的记录
2. 读取完整的行数据（回表）
3. MySQL Server过滤age > 30 AND department = 'IT'的条件
4. 返回符合条件的结果
```

**使用索引下推的情况：**
```
1. MySQL Server将age > 30 AND department = 'IT'条件传递给存储引擎
2. 存储引擎在读取索引时就过滤age > 30 AND department = 'IT'
3. 只有符合条件的记录才进行回表操作
4. 返回结果
```

#### 索引下推的优势

```sql
-- 性能对比示例
-- 假设索引name LIKE 'John%'匹配1000条记录
-- 其中只有100条满足age > 30 AND department = 'IT'

-- 不使用ICP：需要回表1000次
-- 使用ICP：只需要回表100次
-- 性能提升：约90%
```

#### 索引下推的使用场景

```sql
-- 场景1：LIKE + 范围查询
CREATE INDEX idx_name_salary ON employees (name, salary);

SELECT * FROM employees 
WHERE name LIKE 'John%' AND salary > 50000;
-- ICP可以过滤salary > 50000的条件

-- 场景2：范围查询 + 等值查询
CREATE INDEX idx_age_dept_name ON employees (age, department, name);

SELECT * FROM employees 
WHERE age > 25 AND department = 'IT' AND name LIKE 'A%';
-- ICP可以过滤department = 'IT'的条件

-- 场景3：多范围条件
CREATE INDEX idx_hire_date_salary ON employees (hire_date, salary);

SELECT * FROM employees 
WHERE hire_date > '2020-01-01' 
  AND salary BETWEEN 40000 AND 80000;
-- ICP可以过滤salary BETWEEN 40000 AND 80000的条件
```

#### 索引下推的限制

```sql
-- 限制1：不支持存储函数
CREATE INDEX idx_name_upper ON employees (name, UPPER(department));

SELECT * FROM employees 
WHERE name = 'John' AND UPPER(department) = 'IT';
-- ICP不生效，因为UPPER(department)是函数

-- 限制2：不支持子查询
SELECT * FROM employees e1
WHERE name = 'John' 
  AND EXISTS (SELECT 1 FROM employees e2 WHERE e2.id = e1.id AND e2.salary > 50000);
-- ICP不生效，因为包含子查询

-- 限制3：不支持某些存储引擎
-- MyISAM支持ICP，但性能提升有限
-- InnoDB支持ICP，效果显著
```

#### 索引下推的性能验证

```sql
-- 启用和禁用ICP进行对比
-- 禁用ICP
SET optimizer_switch = 'index_condition_pushdown=off';

EXPLAIN SELECT * FROM employees 
WHERE name LIKE 'John%' AND age > 30 AND department = 'IT';
-- Extra: Using where; Using index

-- 启用ICP
SET optimizer_switch = 'index_condition_pushdown=on';

EXPLAIN SELECT * FROM employees 
WHERE name LIKE 'John%' AND age > 30 AND department = 'IT';
-- Extra: Using index condition
```

#### 实际应用建议

```sql
-- 建议1：合理设计组合索引
-- 将过滤性强的列放在索引前面
CREATE INDEX idx_optimized ON employees (
    department,  -- 过滤性强
    age,         -- 范围查询
    name         -- LIKE查询
);

-- 建议2：监控ICP效果
-- 使用Performance Schema监控
SELECT * FROM performance_schema.optimizer_trace 
WHERE QUERY LIKE '%employees%';

-- 建议3：避免过度依赖ICP
-- ICP只是优化手段之一，还需考虑：
-- 1. 索引选择性
-- 2. 查询频率
-- 3. 数据分布
```

### 5.1.4 Filesort优化策略

**Q: Filesort是什么？什么时候会发生Filesort？**

Filesort是MySQL在无法使用索引完成排序时采用的排序算法，它会将需要排序的数据读入内存或临时文件中进行排序。

#### Filesort的发生场景

```sql
-- 场景1：没有合适的索引
CREATE TABLE products (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    price DECIMAL(10,2),
    category_id INT,
    created_at TIMESTAMP
);

-- 查询：按价格排序但没有索引
SELECT * FROM products ORDER BY price DESC LIMIT 10;
-- 会发生Filesort

-- 场景2：索引无法满足排序需求
CREATE INDEX idx_category_price ON products (category_id, price);

-- 查询：按价格排序但过滤条件在后面
SELECT * FROM products WHERE price > 100 ORDER BY category_id;
-- 会发生Filesort，因为索引是(category_id, price)，但排序是category_id

-- 场景3：SELECT字段不在索引中
CREATE INDEX idx_price ON products (price);

-- 查询：需要回表但排序字段在索引中
SELECT name, price FROM products ORDER BY price;
-- 不会发生Filesort（覆盖索引）

-- 查询：需要回表且排序字段在索引中
SELECT * FROM products ORDER BY price;
-- 会发生Filesort（需要回表）
```

#### Filesort的优化策略

```sql
-- 策略1：创建合适的索引
-- 原查询
SELECT * FROM products 
WHERE category_id = 5 
ORDER BY price DESC 
LIMIT 10;

-- 优化：创建组合索引
CREATE INDEX idx_category_price ON products (category_id, price DESC);
-- 现在可以使用索引排序，避免Filesort

-- 策略2：使用覆盖索引
-- 原查询
SELECT id, name, price FROM products ORDER BY price DESC LIMIT 10;

-- 优化：创建覆盖索引
CREATE INDEX idx_covering ON products (price DESC, id, name);
-- 避免回表和Filesort

-- 策略3：调整查询逻辑
-- 原查询（可能导致Filesort）
SELECT * FROM products 
WHERE name LIKE '%phone%' 
ORDER BY price DESC 
LIMIT 10;

-- 优化：使用全文索引或搜索引擎
-- 或者分页优化
SELECT * FROM products 
WHERE name LIKE '%phone%' 
ORDER BY id  -- 使用主键排序
LIMIT 10 OFFSET 100;
```

#### Filesort的性能分析

```sql
-- 分析查询是否使用Filesort
EXPLAIN SELECT * FROM products ORDER BY price DESC LIMIT 10;
/*
如果Extra列显示：
- "Using filesort"：使用了Filesort
- "Using index" 或 "Using where"：没有使用Filesort
*/

-- 优化前的执行计划
EXPLAIN SELECT * FROM products ORDER BY price DESC LIMIT 10;
/*
id  select_type  table     type  possible_keys  key     key_len  ref  rows  Extra
1   SIMPLE       products  ALL   NULL           NULL    NULL     NULL 1000  Using filesort
*/

-- 优化后的执行计划
CREATE INDEX idx_price ON products (price DESC);
EXPLAIN SELECT id, name, price FROM products ORDER BY price DESC LIMIT 10;
/*
id  select_type  table     type  possible_keys  key        key_len  ref  rows  Extra
1   SIMPLE       products  index NULL           idx_price  5        NULL 10    Using index
*/
```

#### Filesort的参数调优

```sql
-- 相关系统参数
-- sort_buffer_size：每个线程的排序缓冲区大小
SHOW VARIABLES LIKE 'sort_buffer_size';
-- 默认值：262144 (256KB)

-- max_length_for_sort_data：控制排序数据的最大长度
SHOW VARIABLES LIKE 'max_length_for_sort_data';
-- 默认值：1024

-- 优化参数设置
-- 适当增大sort_buffer_size（根据内存情况）
SET SESSION sort_buffer_size = 2097152;  -- 2MB

-- 注意：sort_buffer_size是每个线程的，不宜设置过大
```

#### Filesort的替代方案

```sql
-- 方案1：使用索引替代排序
-- 原查询
SELECT * FROM orders ORDER BY created_at DESC LIMIT 20;

-- 优化：创建索引
CREATE INDEX idx_created_at ON orders (created_at DESC);

-- 方案2：使用应用层缓存
-- 对于不经常变化的数据，可以在应用层缓存排序结果

-- 方案3：使用搜索引擎
-- 对于复杂的全文搜索和排序，使用Elasticsearch等搜索引擎

-- 方案4：分页优化
-- 避免深度分页
SELECT * FROM products 
WHERE id > 10000  -- 使用上次查询的最大ID
ORDER BY price DESC 
LIMIT 20;
```

## 5.2 事务机制

**Q: 数据库事务的ACID特性？**
- **原子性（Atomicity）**：事务是最小执行单位，要么全部成功，要么全部失败
- **一致性（Consistency）**：事务执行前后，数据库从一个一致性状态转换到另一个一致性状态
- **隔离性（Isolation）**：并发执行的事务之间不能相互干扰
- **持久性（Durability）**：事务一旦提交，对数据库的改变是永久性的

**Q: 事务的隔离级别及问题？**
- **读未提交（Read Uncommitted）**：最低隔离级别，存在脏读问题
- **读已提交（Read Committed）**：存在不可重复读问题
- **可重复读（Repeatable Read）**：MySQL默认级别，存在幻读问题
- **串行化（Serializable）**：最高隔离级别，性能最差

## 5.3 连接池

**Q: 数据库连接池的作用和原理？**
- **作用**：减少连接创建和销毁的开销，提高系统性能
- **原理**：预先创建一定数量的连接，放入连接池中，使用时从池中获取，使用完后归还
- **常用连接池**：HikariCP、Druid、C3P0

**Q: 连接池的核心参数？**
- **初始连接数**：连接池启动时创建的连接数
- **最小空闲连接数**：连接池保持的最小连接数
- **最大连接数**：连接池允许的最大连接数
- **连接超时时间**：获取连接的最大等待时间



## 16库16表支撑最近2年数据写入

- 单表存放500万数据，16个库16个表，每天增长100万数据
- 单表可以存放5天数据，256个表 = 1280天 ≈ 3.5年
- 按照时间分表，每个库包含16张表，通过哈希或时间规则路由数据
- 支持水平扩展，便于维护和备份


## 数据冷热隔离策略

根据App用户使用情况，将数据进行冷热隔离存储：

### 热数据（近一个月）
- **存储方式**：MySQL主库
- **特点**：访问频率高，需要快速响应
- **优化策略**：
  - 建立合适的索引
  - 使用缓存机制
  - 定期清理过期数据

### 温数据（近一年）
- **存储方式**：MySQL归档库
- **特点**：访问频率中等，偶尔查询
- **优化策略**：
  - 分区存储
  - 压缩存储
  - 定期备份

### 冷数据（一年以上）
- **存储方式**：HBase + Elasticsearch
- **特点**：访问频率低，主要用于历史数据分析
- **优势**：
  - HBase支持海量数据存储
  - ES支持全文检索和复杂分析
  - 成本低廉，扩展性好

### 数据迁移策略
- 每月定期将过期的热数据迁移到温库
- 每季度将过期的温数据迁移到冷存储
- 通过定时任务和ETL工具实现自动化迁移


## 5.4 MySQL 主从同步原理

### 5.4.1 主从同步基本概念

**Q: 什么是 MySQL 主从同步？**

MySQL 主从同步（Replication）是一种数据复制技术，允许将一个 MySQL 数据库服务器（主库）的数据自动复制到一个或多个 MySQL 数据库服务器（从库）。主库负责处理写操作，从库负责处理读操作，实现读写分离，提高数据库性能和可用性。

**主从同步的核心优势：**
- **读写分离**：分散数据库压力，提高并发处理能力
- **数据备份**：提供数据冗余，增强数据安全性
- **高可用性**：主库故障时可快速切换到从库
- **负载均衡**：多个从库可分担读请求压力
- **数据分析**：在从库进行报表统计等分析操作，不影响主库性能

### 5.4.2 主从同步核心原理

**Q: MySQL 主从同步的核心工作原理？**

MySQL 主从同步基于二进制日志（Binary Log）实现，采用异步复制方式。整个同步过程主要依赖两个关键线程：

#### 核心线程

1. **I/O线程**：负责从主库读取二进制日志（Binary Log）内容，并将其写入到从库的中继日志（Relay Log）中
2. **SQL线程**：负责读取中继日志（Relay Log）中的内容，并在从库上执行，从而实现数据同步

#### 工作流程

```
1. 主库写入数据时，将操作记录到 Binary Log（二进制日志）中
2. 从库的 I/O 线程连接到主库，读取 Binary Log 内容并写入 Relay Log（中继日志）
3. 从库的 SQL 线程读取 Relay Log 中的SQL语句并在从库上执行
4. 最终实现主从库数据一致
```

### 5.4.3 主从同步的三种方式

**Q: MySQL 主从同步有哪几种方式？有什么区别？**

MySQL 主从同步根据数据一致性和性能要求，主要分为三种复制方式：

#### 1. 异步复制（Asynchronous Replication）- 默认方式

```sql
-- 特点：
-- - 主库写入完成后立即返回成功，不等待从库确认
-- - 从库异步拉取主库的二进制日志进行同步
-- - 性能最好，但存在数据丢失风险
-- - 主库宕机时可能丢失未同步到从库的数据
```

**工作流程：**
```
1. 客户端写入主库
2. 主库写入完成并记录到 Binary Log
3. 主库立即返回成功给客户端
4. 从库的 I/O 线程异步连接主库获取 Binary Log
5. 从库的 SQL 线程执行 Relay Log 中的SQL语句
```

**优点：**
- 性能最佳，主库写入延迟最小
- 网络故障不影响主库写入操作
- 配置简单，无需额外设置

**缺点：**
- 数据一致性无法保证
- 主库宕机可能丢失未同步的数据
- 无法确定从库数据的实时性

#### 2. 半同步复制（Semi-synchronous Replication）

```sql
-- 特点：
-- - 主库写入后至少等待一个从库确认接收日志
-- - 在数据一致性和性能之间取得平衡
-- - MySQL 5.5 开始支持，需要安装插件
```

**工作流程：**
```
1. 客户端写入主库
2. 主库写入完成并记录到 Binary Log
3. 主库等待至少一个从库确认接收日志
4. 从库的 I/O 线程接收 Binary Log 并发送确认
5. 主库收到确认后返回成功给客户端
6. 从库的 SQL 线程执行 Relay Log 中的SQL语句
```

**优点：**
- 相比异步复制，数据安全性更高
- 至少有一个从库拥有完整的数据副本
- 性能影响相对较小

**缺点：**
- 网络延迟会影响主库写入性能
- 仍然不能保证数据完全不丢失
- 需要额外配置和管理

#### 3. 全同步复制（Fully Synchronous Replication）

```sql
-- 特点：
-- - 主库写入需要等待所有从库确认
-- - 数据一致性最高，但性能最差
-- - MySQL 原生不支持，需要第三方解决方案
```

**工作流程：**
```
1. 客户端写入主库
2. 主库写入完成并记录到 Binary Log
3. 主库等待所有从库确认接收并应用日志
4. 所有从库的 I/O 线程接收 Binary Log 并发送确认
5. 所有从库的 SQL 线程执行完 Relay Log 中的SQL语句
6. 主库收到所有确认后返回成功给客户端
```

**优点：**
- 数据一致性最高
- 几乎不会出现数据丢失
- 适合对数据一致性要求极高的场景

**缺点：**
- 性能最差，写入延迟最高
- 任何一个从库故障都会影响写入操作
- 网络延迟会严重影响整体性能

#### 三种复制方式对比表

| 复制方式 | 数据一致性 | 性能 | 配置复杂度 | 适用场景 |
|---------|-----------|------|-----------|---------|
| 异步复制 | 低 | 高 | 低 | 对性能要求高，可容忍少量数据丢失 |
| 半同步复制 | 中 | 中 | 中 | 对数据一致性有一定要求，但不能牺牲太多性能 |
| 全同步复制 | 高 | 低 | 高 | 对数据一致性要求极高，可接受性能损失 |

### 5.4.4 主从同步模式

**Q: MySQL 主从同步有哪些模式？**

MySQL 主从同步主要分为以下几种模式：

#### 1. 单主单从模式

```
-- 特点：
-- - 一个主库，一个从库
-- - 简单易用，适合小型应用
```

#### 2. 单主多从模式

```
-- 特点：
-- - 一个主库，多个从库
-- - 提高读性能，支持负载均衡
```

#### 3. 主主模式

```
-- 特点：
-- - 多个主库，互相复制
-- - 高可用性，但配置复杂
```

#### 4. 级联复制模式

```
-- 特点：
-- - 主库 -> 从库1 -> 从库2
-- - 适合跨地域部署，减少延迟
```

### 5.4.5 主从同步配置

**Q: 如何配置 MySQL 主从同步？**

配置 MySQL 主从同步需要以下几个步骤：

#### 1. 配置主库

```
-- my.cnf 配置文件
server-id = 1
log-bin = /var/log/mysql/mysql-bin.log
binlog-do-db = mydatabase
```

#### 2. 配置从库

```
-- my.cnf 配置文件
server-id = 2
relay-log = /var/log/mysql/mysql-relay-bin.log
log-slave-updates = 1
read-only = 1
```

#### 3. 创建复制用户

```
-- 在主库上创建复制用户
CREATE USER 'repl'@'%' IDENTIFIED BY 'password';
GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%';
FLUSH PRIVILEGES;
```

#### 4. 获取主库状态

```
-- 在主库上执行
SHOW MASTER STATUS;
```

#### 5. 配置从库连接主库

```
-- 在从库上执行
CHANGE MASTER TO
  MASTER_HOST='master_host',
  MASTER_USER='repl',
  MASTER_PASSWORD='password',
  MASTER_LOG_FILE='mysql-bin.000001',
  MASTER_LOG_POS=107;
```

#### 6. 启动从库复制

```
-- 在从库上执行
START SLAVE;
```

#### 7. 验证同步状态

```
-- 在从库上执行
SHOW SLAVE STATUS\G
```

### 5.4.6 主从同步优化

**Q: 如何优化 MySQL 主从同步？**

优化 MySQL 主从同步可以从以下几个方面入手：

#### 1. 优化网络延迟

```
-- 使用高速网络连接主从库
-- 配置合适的网络带宽
```

#### 2. 优化主库性能

```
-- 减少主库的写操作
-- 使用合适的硬件配置
```

#### 3. 优化从库性能

```
-- 使用合适的硬件配置
-- 配置合适的缓冲区大小
```

#### 4. 优化复制配置

```
-- 调整 binlog_format
-- 配置合适的 relay_log_space_limit
```

## 5.5 MVCC机制

**Q: 什么是MVCC（多版本并发控制）？**

MVCC是数据库并发控制的一种机制，通过保存数据的多个版本来实现非阻塞的读操作。

**MVCC的核心组件：**
- **隐藏列**：每行数据包含事务ID和版本号
- **Read View**：记录当前活跃事务的快照
- **Undo Log**：存储数据的历史版本

**SQL执行顺序示例：**
```sql
-- 1. FROM 表连接
-- 2. WHERE条件过滤
-- 3. GROUP BY分组
-- 4. HAVING条件过滤
-- 5. SELECT选择字段
-- 6. ORDER BY排序
-- 7. LIMIT限制结果数

SELECT t.id, COUNT(*) as count FROM t 
JOIN u ON t.id = u.t_id 
WHERE t.id > 0 
GROUP BY t.id 
HAVING count > 1 
ORDER BY t.id DESC 
LIMIT 10;
```