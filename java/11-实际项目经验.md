# 11. 实际项目经验

## 目录
- [如何设计高并发系统](#如何设计高并发系统)
- [线上问题排查思路](#线上问题排查思路)
  - [10.1 监控指标分析案例](#101-监控指标分析案例)
    - [CPU使用率异常排查](#cpu使用率异常排查)
    - [内存使用监控和分析](#内存使用监控和分析)
    - [网络和磁盘I/O监控](#网络和磁盘I/O监控)
  - [10.2 分析堆栈案例](#102-分析堆栈案例)
    - [死锁排查案例](#死锁排查案例)
    - [死锁检测和分析](#死锁检测和分析)
    - [线程dump分析要点](#线程dump分析要点)
    - [内存溢出堆dump分析](#内存溢出堆dump分析)
  - [10.3 性能分析实战案例](#103-性能分析实战案例)
    - [使用Arthas进行在线诊断](#使用Arthas进行在线诊断)
    - [JProfiler性能分析案例](#jprofiler性能分析案例)

---

## 如何设计高并发系统

**Q: 如何设计高并发系统？**
1. **分层架构**：接入层、业务层、数据层
2. **负载均衡**：Nginx、LVS分发请求
3. **缓存策略**：Redis缓存热点数据
4. **数据库优化**：读写分离、分库分表
5. **异步处理**：消息队列处理耗时操作
6. **熔断降级**：Hystrix保护系统稳定性
7. **监控告警**：实时监控系统状态

## 线上问题排查思路

**Q: 线上问题排查思路？**

### 10.1 监控指标分析案例

#### CPU使用率异常排查
```bash
# 1. 查看系统整体CPU使用情况
top -p `pgrep java`

# 2. 查看具体线程CPU使用情况
top -H -p <java_pid>

# 3. 将线程ID转换为16进制，在线程dump中查找
printf "%x\n" <thread_id>

# 4. 生成线程dump分析CPU占用高的线程
jstack <java_pid> > thread_dump.txt
```

#### 内存使用监控和分析
```java
// Java代码监控内存使用情况
public class MemoryMonitor {
    
    public static void printMemoryInfo() {
        MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();
        MemoryUsage heapUsage = memoryBean.getHeapMemoryUsage();
        MemoryUsage nonHeapUsage = memoryBean.getNonHeapMemoryUsage();
        
        System.out.println("=== 堆内存使用情况 ===");
        System.out.println("已使用: " + (heapUsage.getUsed() / 1024 / 1024) + " MB");
        System.out.println("已提交: " + (heapUsage.getCommitted() / 1024 / 1024) + " MB");
        System.out.println("最大值: " + (heapUsage.getMax() / 1024 / 1024) + " MB");
        System.out.println("使用率: " + String.format("%.2f%%", 
            (double) heapUsage.getUsed() / heapUsage.getMax() * 100));
        
        System.out.println("\n=== 非堆内存使用情况 ===");
        System.out.println("已使用: " + (nonHeapUsage.getUsed() / 1024 / 1024) + " MB");
        System.out.println("已提交: " + (nonHeapUsage.getCommitted() / 1024 / 1024) + " MB");
    }
    
    // 监控GC情况
    public static void printGCInfo() {
        List<GarbageCollectorMXBean> gcBeans = ManagementFactory.getGarbageCollectorMXBeans();
        System.out.println("\n=== GC统计信息 ===");
        for (GarbageCollectorMXBean gcBean : gcBeans) {
            System.out.println("GC名称: " + gcBean.getName());
            System.out.println("GC次数: " + gcBean.getCollectionCount());
            System.out.println("GC总时间: " + gcBean.getCollectionTime() + "ms");
            System.out.println("平均GC时间: " + 
                (gcBean.getCollectionCount() > 0 ? 
                    gcBean.getCollectionTime() / gcBean.getCollectionCount() : 0) + "ms");
            System.out.println("---");
        }
    }
}
```

#### 网络和磁盘I/O监控
```bash
# 网络连接数监控
netstat -an | grep :8080 | wc -l  # 统计8080端口连接数
ss -s  # 查看socket统计信息

# 磁盘I/O监控
iostat -x 1  # 每秒显示磁盘I/O统计
lsof -p <java_pid>  # 查看进程打开的文件
```

### 10.2 分析堆栈案例

#### 死锁排查案例
```java
// 模拟死锁场景
public class DeadlockExample {
    private static final Object lock1 = new Object();
    private static final Object lock2 = new Object();
    
    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (lock1) {
                System.out.println("Thread1: Holding lock1...");
                try { Thread.sleep(100); } catch (InterruptedException e) {}
                synchronized (lock2) {
                    System.out.println("Thread1: Holding lock1 & lock2...");
                }
            }
        }).start();
        
        new Thread(() -> {
            synchronized (lock2) {
                System.out.println("Thread2: Holding lock2...");
                try { Thread.sleep(100); } catch (InterruptedException e) {}
                synchronized (lock1) {
                    System.out.println("Thread2: Holding lock2 & lock1...");
                }
            }
        }).start();
    }
}
```

#### 死锁检测和分析
```bash
# 1. 生成线程dump
jstack <java_pid> > deadlock_analysis.txt

# 2. 或使用jcmd命令
jcmd <java_pid> Thread.print > thread_dump.txt

# 3. 使用VisualVM图形化分析
# 在VisualVM中查看Threads标签，可以直观看到死锁
```

#### 线程dump分析要点
```
# 在dump文件中查找关键信息：
# 1. 死锁检测结果
Found 2 deadlocks.

# 2. 线程状态
"Thread-1" #10 prio=5 os_prio=31 tid=0x... nid=0x... waiting for monitor entry
   java.lang.Thread.State: BLOCKED (on object monitor)

# 3. 锁等待链
waiting to lock <0x000000076ab62208> (a java.lang.Object)
locked <0x000000076ab62218> (a java.lang.Object)
```

#### 内存溢出堆dump分析
```bash
# 1. 生成堆dump（OOM时自动生成）
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/path/to/heapdump.hprof

# 2. 手动生成堆dump
jmap -dump:format=b,file=heap_dump.hprof <java_pid>

# 3. 使用MAT (Memory Analyzer Tool) 分析
# - 查看Histogram找到占用内存最多的对象
# - 查看Dominator Tree分析对象引用关系
# - 使用OQL查询特定对象
SELECT * FROM java.lang.String s WHERE s.count > 1000
```

### 10.3 性能分析实战案例

#### 使用Arthas进行在线诊断
```bash
# 1. 启动Arthas
java -jar arthas-boot.jar

# 2. 查看JVM信息
dashboard  # 实时数据面板
jvm        # JVM详细信息

# 3. 监控方法执行时间
monitor -c 5 com.example.UserService getUserById  # 每5秒统计一次

# 4. 查看方法调用堆栈
trace com.example.UserService getUserById  # 追踪方法调用链

# 5. 观察方法参数和返回值
watch com.example.UserService getUserById "{params,returnObj}" -x 2

# 6. 查看热点方法
profiler start  # 开始性能采样
profiler stop   # 停止并生成火焰图
```

#### JProfiler性能分析案例
```java
// 性能测试代码
public class PerformanceTest {
    
    // CPU密集型任务分析
    public void cpuIntensiveTask() {
        List<Integer> numbers = new ArrayList<>();
        for (int i = 0; i < 1000000; i++) {
            numbers.add(calculatePrime(i));  // 计算质数
        }
    }
    
    // 内存密集型任务分析
    public void memoryIntensiveTask() {
        List<String> strings = new ArrayList<>();
        for (int i = 0; i < 100000; i++) {
            strings.add("String_" + i + "_" + System.currentTimeMillis());
        }
    }
    
    // 分析要点：
    // 1. CPU采样：找出耗时最多的方法
    // 2. 内存分析：找出创建最多对象的地方
    // 3. 线程分析：找出阻塞时间最长的线程
    // 4. 数据库分析：找出最慢的SQL语句
}
```

#### 应用性能监控(APM)实战
```yaml
# application.yml - 集成Micrometer监控
management:
  endpoints:
    web:
      exposure:
        include: "*"
  metrics:
    export:
      prometheus:
        enabled: true
  endpoint:
    metrics:
      enabled: true
    prometheus:
      enabled: true
```

```java
// 自定义性能监控
@Component
public class PerformanceMonitor {
    
    private final MeterRegistry meterRegistry;
    
    @EventListener
    public void handleMethodExecution(MethodExecutionEvent event) {
        Timer timer = Timer.builder("method_execution_time")
                          .tag("class", event.getClassName())
                          .tag("method", event.getMethodName())
                          .register(meterRegistry);
        
        timer.record(event.getExecutionTime(), TimeUnit.MILLISECONDS);
    }
}
```

### 10.4 数据库分析实战案例

#### 慢查询日志分析
```sql
-- 1. 开启慢查询日志
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 2;  -- 超过2秒的查询记录
SET GLOBAL log_queries_not_using_indexes = 'ON';

-- 2. 分析慢查询
-- 使用mysqldumpslow工具
-- mysqldumpslow -s t -t 10 /path/to/slow.log
```

#### 执行计划分析案例
```sql
-- 问题SQL示例
SELECT u.username, p.title, c.content 
FROM users u 
JOIN posts p ON u.id = p.user_id 
JOIN comments c ON p.id = c.post_id 
WHERE u.created_time > '2023-01-01' 
AND p.status = 'published'
ORDER BY p.created_time DESC
LIMIT 10;
```

**排查步骤**：
1. **查看执行计划**：`EXPLAIN SELECT ...`
2. **识别性能瓶颈**：
   - 是否使用了合适的索引
   - 是否存在全表扫描
   - JOIN操作是否高效
3. **优化建议**：
   - 添加复合索引：`(user_id, status, created_time)`
   - 考虑分页优化
   - 使用覆盖索引减少回表

#### 系统性问题排查方法论

**排查流程**：
1. **现象观察**：记录问题现象和发生时间
2. **指标监控**：查看CPU、内存、磁盘、网络等系统指标
3. **日志分析**：检查应用日志、系统日志、数据库日志
4. **代码审查**：结合业务代码分析可能的问题点
5. **修复验证**：实施修复方案并验证效果