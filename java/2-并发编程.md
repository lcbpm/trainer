# 2. 并发编程

## 目录
- [2.1 线程基础](#21-线程基础)
- [2.2 锁机制](#22-锁机制)
- [2.3 并发工具类](#23-并发工具类)
- [2.4 并发编程实战代码](#24-并发编程实战代码)

---

## 2.1 线程基础

### 线程状态和生命周期

Java线程具有以下6种状态：

1. **NEW（新建）**：线程刚被创建，但尚未启动
2. **RUNNABLE（可运行）**：线程正在Java虚拟机中执行，可能正在等待操作系统资源（如处理器）
3. **BLOCKED（阻塞）**：线程被阻塞等待监视器锁
4. **WAITING（无限期等待）**：线程等待其他线程执行特定操作
5. **TIMED_WAITING（限期等待）**：线程等待其他线程执行特定操作，但有时间限制
6. **TERMINATED（终止）**：线程已执行完毕

```java
public class ThreadStateDemo {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -> {
            synchronized (ThreadStateDemo.class) {
                try {
                    Thread.sleep(1000); // TIMED_WAITING
                    ThreadStateDemo.class.wait(); // WAITING
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });
        
        System.out.println("初始状态: " + thread.getState()); // NEW
        
        thread.start();
        System.out.println("启动后状态: " + thread.getState()); // RUNNABLE
        
        Thread.sleep(100);
        System.out.println("睡眠时状态: " + thread.getState()); // TIMED_WAITING
        
        synchronized (ThreadStateDemo.class) {
            ThreadStateDemo.class.notify(); // 唤醒线程
        }
        
        thread.join();
        System.out.println("终止状态: " + thread.getState()); // TERMINATED
    }
}
```

### 线程创建方式

Java中创建线程主要有以下几种方式：

1. **继承Thread类**
```java
class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("继承Thread类创建线程");
    }
}
```

2. **实现Runnable接口**
```java
class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("实现Runnable接口创建线程");
    }
}
```

3. **实现Callable接口**
```java
class MyCallable implements Callable<String> {
    @Override
    public String call() throws Exception {
        return "实现Callable接口创建线程";
    }
}
```

4. **使用线程池**
```java
ExecutorService executor = Executors.newFixedThreadPool(10);
executor.submit(() -> System.out.println("使用线程池创建线程"));
```

### 线程安全问题

线程安全问题主要由以下三个条件构成：
1. **共享数据**：多个线程同时访问同一份数据
2. **多线程环境**：存在多个线程并发执行
3. **非原子操作**：对共享数据的操作不是原子性的

```java
public class ThreadSafetyDemo {
    private static int count = 0;
    
    // 非线程安全的计数器
    public static void unsafeIncrement() {
        count++; // 非原子操作：读取->增加->写入
    }
    
    // 线程安全的计数器
    public static synchronized void safeIncrement() {
        count++;
    }
    
    // 使用AtomicInteger实现线程安全
    private static AtomicInteger atomicCount = new AtomicInteger(0);
    
    public static void atomicIncrement() {
        atomicCount.incrementAndGet();
    }
}
```

## 2.2 锁机制

### synchronized关键字

synchronized是Java中最基本的同步机制，可以修饰：
1. **实例方法**：锁住当前实例对象
2. **静态方法**：锁住当前类的Class对象
3. **代码块**：锁住指定对象

```java
public class SynchronizedDemo {
    private int count = 0;
    
    // 锁住当前实例
    public synchronized void increment() {
        count++;
    }
    
    // 锁住当前类
    public static synchronized void staticMethod() {
        // ...
    }
    
    // 锁住指定对象
    public void blockSync() {
        synchronized (this) {
            count++;
        }
    }
}
```

### ReentrantLock可重入锁

ReentrantLock是java.util.concurrent包提供的可重入锁，相比synchronized具有更多功能：

```java
import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockDemo {
    private final ReentrantLock lock = new ReentrantLock();
    private int count = 0;
    
    public void increment() {
        lock.lock();
        try {
            count++;
        } finally {
            lock.unlock(); // 必须在finally中释放锁
        }
    }
    
    // 尝试获取锁
    public boolean tryIncrement() {
        if (lock.tryLock()) {
            try {
                count++;
                return true;
            } finally {
                lock.unlock();
            }
        }
        return false;
    }
    
    // 带超时的锁获取
    public boolean tryIncrementWithTimeout() throws InterruptedException {
        if (lock.tryLock(1, TimeUnit.SECONDS)) {
            try {
                count++;
                return true;
            } finally {
                lock.unlock();
            }
        }
        return false;
    }
}
```

### 读写锁ReadWriteLock

读写锁允许多个读操作并发执行，但写操作是独占的：

```java
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class ReadWriteLockDemo {
    private final ReadWriteLock lock = new ReentrantReadWriteLock();
    private String data = "initial";
    
    // 读操作
    public String read() {
        lock.readLock().lock();
        try {
            return data;
        } finally {
            lock.readLock().unlock();
        }
    }
    
    // 写操作
    public void write(String newData) {
        lock.writeLock().lock();
        try {
            data = newData;
        } finally {
            lock.writeLock().unlock();
        }
    }
}
```

### 锁的分类

1. **可重入锁**：同一个线程可以多次获取同一把锁
2. **公平锁**：按照线程请求锁的顺序来获取锁
3. **非公平锁**：允许插队，可能造成线程饥饿
4. **独占锁**：只能被一个线程持有
5. **共享锁**：可以被多个线程同时持有

## 2.3 并发工具类

### CountDownLatch

CountDownLatch允许一个或多个线程等待其他线程完成操作：

```java
import java.util.concurrent.CountDownLatch;

public class CountDownLatchDemo {
    public static void main(String[] args) throws InterruptedException {
        int threadCount = 5;
        CountDownLatch latch = new CountDownLatch(threadCount);
        
        for (int i = 0; i < threadCount; i++) {
            new Thread(() -> {
                System.out.println(Thread.currentThread().getName() + " 完成任务");
                latch.countDown(); // 计数器减1
            }, "Thread-" + i).start();
        }
        
        latch.await(); // 等待计数器归零
        System.out.println("所有任务完成");
    }
}
```

### CyclicBarrier

CyclicBarrier让一组线程相互等待，直到所有线程都到达屏障点：

```java
import java.util.concurrent.CyclicBarrier;

public class CyclicBarrierDemo {
    public static void main(String[] args) {
        int threadCount = 3;
        CyclicBarrier barrier = new CyclicBarrier(threadCount, () -> {
            System.out.println("所有线程都到达屏障点，开始执行汇总任务");
        });
        
        for (int i = 0; i < threadCount; i++) {
            new Thread(() -> {
                try {
                    System.out.println(Thread.currentThread().getName() + " 到达屏障点");
                    barrier.await(); // 等待其他线程
                    System.out.println(Thread.currentThread().getName() + " 继续执行");
                } catch (Exception e) {
                    Thread.currentThread().interrupt();
                }
            }, "Thread-" + i).start();
        }
    }
}
```

### Semaphore

Semaphore用于控制同时访问特定资源的线程数量：

```java
import java.util.concurrent.Semaphore;

public class SemaphoreDemo {
    private static final Semaphore semaphore = new Semaphore(3); // 允许3个线程同时访问
    
    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                try {
                    semaphore.acquire(); // 获取许可
                    System.out.println(Thread.currentThread().getName() + " 获得许可");
                    Thread.sleep(2000); // 模拟业务处理
                    System.out.println(Thread.currentThread().getName() + " 释放许可");
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } finally {
                    semaphore.release(); // 释放许可
                }
            }, "Thread-" + i).start();
        }
    }
}
```

### Exchanger

Exchanger用于两个线程之间交换数据：

```java
import java.util.concurrent.Exchanger;

public class ExchangerDemo {
    public static void main(String[] args) {
        Exchanger<String> exchanger = new Exchanger<>();
        
        new Thread(() -> {
            try {
                String data = "Thread-A的数据";
                System.out.println("Thread-A 准备交换数据: " + data);
                String received = exchanger.exchange(data);
                System.out.println("Thread-A 收到数据: " + received);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }, "Thread-A").start();
        
        new Thread(() -> {
            try {
                String data = "Thread-B的数据";
                System.out.println("Thread-B 准备交换数据: " + data);
                String received = exchanger.exchange(data);
                System.out.println("Thread-B 收到数据: " + received);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }, "Thread-B").start();
    }
}
```

## 2.4 并发编程实战代码

### 生产者消费者模式

使用BlockingQueue实现生产者消费者模式：

```java
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class ProducerConsumerDemo {
    private static final BlockingQueue<String> queue = new LinkedBlockingQueue<>(10);
    
    static class Producer implements Runnable {
        @Override
        public void run() {
            try {
                for (int i = 0; i < 20; i++) {
                    String item = "item-" + i;
                    queue.put(item); // 阻塞式放入
                    System.out.println("生产: " + item);
                    Thread.sleep(100);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
    
    static class Consumer implements Runnable {
        @Override
        public void run() {
            try {
                while (true) {
                    String item = queue.take(); // 阻塞式取出
                    System.out.println("消费: " + item);
                    Thread.sleep(200);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
    
    public static void main(String[] args) {
        new Thread(new Producer(), "Producer").start();
        new Thread(new Consumer(), "Consumer").start();
    }
}
```

### 线程池使用示例

```java
import java.util.concurrent.*;

public class ThreadPoolDemo {
    public static void main(String[] args) {
        // 创建固定大小的线程池
        ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5);
        
        // 创建缓存线程池
        ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
        
        // 创建单线程池
        ExecutorService singleThreadPool = Executors.newSingleThreadExecutor();
        
        // 创建定时任务线程池
        ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);
        
        // 自定义线程池
        ThreadPoolExecutor customThreadPool = new ThreadPoolExecutor(
            5, // 核心线程数
            10, // 最大线程数
            60L, // 空闲线程存活时间
            TimeUnit.SECONDS, // 时间单位
            new LinkedBlockingQueue<>(100), // 工作队列
            Executors.defaultThreadFactory(), // 线程工厂
            new ThreadPoolExecutor.CallerRunsPolicy() // 拒绝策略
        );
        
        // 提交任务
        for (int i = 0; i < 10; i++) {
            final int taskId = i;
            fixedThreadPool.submit(() -> {
                System.out.println("Task " + taskId + " executed by " + Thread.currentThread().getName());
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
        }
        
        // 关闭线程池
        fixedThreadPool.shutdown();
    }
}
```

### CompletableFuture异步编程

```java
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

public class CompletableFutureDemo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        // 异步执行任务
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            return "Hello";
        });
        
        // 链式调用
        CompletableFuture<String> result = future
            .thenApply(s -> s + " World")
            .thenApply(String::toUpperCase);
        
        // 获取结果
        System.out.println(result.get()); // HELLO WORLD
        
        // 组合多个异步任务
        CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> "Task1");
        CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> "Task2");
        
        CompletableFuture<String> combined = future1.thenCombine(future2, (s1, s2) -> s1 + " " + s2);
        System.out.println(combined.get()); // Task1 Task2
        
        // 异常处理
        CompletableFuture<String> exceptionalFuture = CompletableFuture.supplyAsync(() -> {
            throw new RuntimeException("Something went wrong");
        }).exceptionally(throwable -> "Error occurred: " + throwable.getMessage());
        
        System.out.println(exceptionalFuture.get()); // Error occurred: java.lang.RuntimeException: Something went wrong
    }
}
```


Java 线程池核心有 **6种**，均通过 `Executors` 工具类创建，核心区别在于 **任务队列类型、线程存活策略、适用场景** 的不同。


### 1. FixedThreadPool（固定线程数线程池）
- **核心参数**：核心线程数 = 最大线程数，无超时时间，任务队列用无界的 `LinkedBlockingQueue`。
- **特点**：线程数固定，空闲线程不会回收，任务队列可无限接收任务（可能导致内存溢出）。
- **适用场景**：处理 **长期、稳定、可预测** 的任务，如服务器接收稳定请求。


### 2. CachedThreadPool（缓存线程池）
- **核心参数**：核心线程数 = 0，最大线程数 = `Integer.MAX_VALUE`，线程空闲超时 60 秒，任务队列用同步队列 `SynchronousQueue`（不存储任务，直接传递）。
- **特点**：线程数随任务量动态增减，空闲线程超时回收，任务无排队（需立即有线程执行）。
- **适用场景**：处理 **短期、突发、数量不确定** 的任务，如临时的异步计算。


### 3. SingleThreadExecutor（单线程线程池）
- **核心参数**：核心线程数 = 最大线程数 = 1，无超时时间，任务队列用无界的 `LinkedBlockingQueue`。
- **特点**：仅1个线程按 **FIFO 顺序** 执行任务，线程意外终止会自动创建新线程维持单线程特性。
- **适用场景**：需要 **串行执行任务** 的场景，如日志写入、订单按顺序处理。


### 4. ScheduledThreadPool（定时/周期性线程池）
- **核心参数**：核心线程数固定，最大线程数 = `Integer.MAX_VALUE`，任务队列用延迟队列 `DelayedWorkQueue`（按延迟时间排序）。
- **特点**：支持 **定时执行（如延迟 3秒执行）** 或 **周期性执行（如每 5秒执行一次）** 任务。
- **适用场景**：定时任务，如定时数据同步、周期性日志清理。


### 5. SingleThreadScheduledExecutor（单线程定时线程池）
- **核心参数**：核心线程数 = 最大线程数 = 1，任务队列用 `DelayedWorkQueue`。
- **特点**：仅1个线程按定时/周期性执行任务，保证任务串行执行，避免并发问题。
- **适用场景**：需要 **串行执行的定时任务**，如单线程处理定时消息推送。


### 6. WorkStealingPool（工作窃取线程池，JDK 1.8+）
- **核心参数**：默认线程数 = CPU 核心数，线程并行度可自定义，每个线程有独立任务队列，支持“工作窃取”（空闲线程偷取其他线程队列的任务）。
- **特点**：基于 Fork/Join 框架，适合 **CPU 密集型任务**，能充分利用多核资源，线程空闲时自动回收。
- **适用场景**：大量 **CPU 密集型任务**（如复杂计算、数据排序），需高效利用多核CPU。


### 核心区别总结表（简化）
| 线程池类型               | 核心线程数 | 最大线程数       | 任务队列类型       | 线程超时 | 核心特点                     |
|--------------------------|------------|------------------|--------------------|----------|------------------------------|
| FixedThreadPool          | 固定值     | 等于核心线程数   | LinkedBlockingQueue | 无       | 线程固定，队列无界           |
| CachedThreadPool         | 0          | Integer.MAX_VALUE | SynchronousQueue   | 60秒     | 线程动态增减，无队列排队     |
| SingleThreadExecutor     | 1          | 1                | LinkedBlockingQueue | 无       | 单线程串行执行，队列无界     |
| ScheduledThreadPool      | 固定值     | Integer.MAX_VALUE | DelayedWorkQueue   | 无       | 支持定时/周期性任务           |
| SingleThreadScheduledExecutor | 1      | 1                | DelayedWorkQueue   | 无       | 单线程执行定时/周期性任务     |
| WorkStealingPool         | CPU核心数  | 灵活分配         | 线程独立队列       | 自动回收 | 工作窃取，适合CPU密集型任务  |


实际开发中，`Executors` 创建的线程池存在隐患（如无界队列导致OOM），推荐用 `ThreadPoolExecutor` 手动配置参数，更灵活可控。需要我帮你写一个 `ThreadPoolExecutor` 的示例代码吗？