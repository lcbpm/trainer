# 3. 集合框架

## 目录
- [3.1 List 实现](#31-list-实现)
- [3.2 Map 实现](#32-map-实现)
- [3.3 集合性能优化](#33-集合性能优化)

---

## 3.1 List 实现

### ArrayList

ArrayList是基于动态数组实现的List，具有以下特点：
- **底层结构**：Object数组
- **特点**：查询快，增删慢
- **线程安全**：非线程安全
- **扩容机制**：默认容量10，扩容为原来的1.5倍

```java
public class ArrayListDemo {
    public static void main(String[] args) {
        // 创建ArrayList
        List<String> list = new ArrayList<>();
        
        // 添加元素
        list.add("A");
        list.add("B");
        list.add("C");
        
        // 访问元素
        System.out.println(list.get(0)); // A
        
        // 删除元素
        list.remove(1); // 删除索引为1的元素
        
        // 遍历
        for (String item : list) {
            System.out.println(item);
        }
    }
}
```

### LinkedList

LinkedList是基于双向链表实现的List，具有以下特点：
- **底层结构**：双向链表
- **特点**：增删快，查询慢
- **线程安全**：非线程安全
- **额外功能**：可以作为栈、队列使用

```java
public class LinkedListDemo {
    public static void main(String[] args) {
        // 创建LinkedList
        LinkedList<String> list = new LinkedList<>();
        
        // 添加元素
        list.add("A");
        list.add("B");
        list.add("C");
        
        // 作为栈使用
        list.push("D"); // 入栈
        System.out.println(list.pop()); // 出栈: D
        
        // 作为队列使用
        list.offer("E"); // 入队
        System.out.println(list.poll()); // 出队: A
    }
}
```

### Vector

Vector是线程安全的动态数组实现：
- **特点**：所有方法都是synchronized修饰
- **性能**：由于同步开销，性能较差
- **替代方案**：推荐使用Collections.synchronizedList()或CopyOnWriteArrayList

```java
public class VectorDemo {
    public static void main(String[] args) {
        // 创建Vector
        Vector<String> vector = new Vector<>();
        
        // 添加元素
        vector.add("A");
        vector.add("B");
        
        // 线程安全操作
        synchronized (vector) {
            for (String item : vector) {
                System.out.println(item);
            }
        }
    }
}
```

### CopyOnWriteArrayList

CopyOnWriteArrayList是线程安全的List实现：
- **特点**：写时复制，读操作无锁
- **适用场景**：读多写少的并发场景
- **性能**：读操作性能好，写操作性能差

```java
public class CopyOnWriteArrayListDemo {
    public static void main(String[] args) {
        // 创建CopyOnWriteArrayList
        CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();
        
        // 添加元素
        list.add("A");
        list.add("B");
        
        // 读操作不需要加锁
        for (String item : list) {
            System.out.println(item);
        }
    }
}
```

## 3.2 Map 实现

### HashMap

HashMap是基于哈希表实现的Map，具有以下特点：
- **底层结构**：数组+链表/红黑树
- **特点**：查询、插入、删除性能好
- **线程安全**：非线程安全
- **容量**：默认容量16，负载因子0.75

```java
public class HashMapDemo {
    public static void main(String[] args) {
        // 创建HashMap
        Map<String, Integer> map = new HashMap<>();
        
        // 添加元素
        map.put("A", 1);
        map.put("B", 2);
        map.put("C", 3);
        
        // 获取元素
        System.out.println(map.get("A")); // 1
        
        // 遍历
        for (Map.Entry<String, Integer> entry : map.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
        
        // Java 8 Stream API
        map.forEach((key, value) -> System.out.println(key + ": " + value));
    }
}
```

### LinkedHashMap

LinkedHashMap继承自HashMap，维护插入顺序或访问顺序：
- **特点**：保持元素插入顺序
- **底层结构**：双向链表+哈希表
- **应用场景**：LRU缓存实现

```java
public class LinkedHashMapDemo {
    public static void main(String[] args) {
        // 保持插入顺序
        LinkedHashMap<String, Integer> map = new LinkedHashMap<>();
        map.put("A", 1);
        map.put("B", 2);
        map.put("C", 3);
        
        // 按插入顺序遍历
        for (Map.Entry<String, Integer> entry : map.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
        
        // LRU缓存实现
        LinkedHashMap<String, Integer> lruCache = new LinkedHashMap<String, Integer>(16, 0.75f, true) {
            @Override
            protected boolean removeEldestEntry(Map.Entry<String, Integer> eldest) {
                return size() > 3; // 最多保留3个元素
            }
        };
        
        lruCache.put("A", 1);
        lruCache.put("B", 2);
        lruCache.put("C", 3);
        lruCache.get("A"); // 访问A，提升优先级
        lruCache.put("D", 4); // 添加D，会移除最久未使用的B
        
        System.out.println(lruCache); // {A=1, C=3, D=4}
    }
}
```

### TreeMap

TreeMap是基于红黑树实现的Map，具有以下特点：
- **特点**：按键排序
- **底层结构**：红黑树
- **性能**：查询、插入、删除时间复杂度都是O(log n)

```java
public class TreeMapDemo {
    public static void main(String[] args) {
        // 创建TreeMap
        TreeMap<String, Integer> map = new TreeMap<>();
        
        // 添加元素
        map.put("C", 3);
        map.put("A", 1);
        map.put("B", 2);
        
        // 按键排序
        for (Map.Entry<String, Integer> entry : map.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
        
        // 获取范围
        SortedMap<String, Integer> subMap = map.subMap("A", "C");
        System.out.println(subMap); // {A=1, B=2}
    }
}
```

### ConcurrentHashMap

ConcurrentHashMap是线程安全的Map实现：
- **特点**：高并发性能好
- **底层结构**：数组+链表/红黑树+Synchronized+CAS
- **性能**：读操作无锁，写操作局部加锁

```java
public class ConcurrentHashMapDemo {
    public static void main(String[] args) {
        // 创建ConcurrentHashMap
        ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();
        
        // 添加元素
        map.put("A", 1);
        map.put("B", 2);
        
        // 原子操作
        map.putIfAbsent("C", 3); // 如果key不存在则添加
        map.replace("A", 1, 10); // 如果key对应的value为1则替换为10
        map.computeIfAbsent("D", key -> key.hashCode()); // 如果key不存在则计算value
        
        // 并发安全遍历
        for (Map.Entry<String, Integer> entry : map.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
    }
}
```

### Hashtable

Hashtable是线程安全的哈希表实现：
- **特点**：所有方法都是synchronized修饰
- **性能**：由于同步开销，性能较差
- **替代方案**：推荐使用ConcurrentHashMap

```java
public class HashtableDemo {
    public static void main(String[] args) {
        // 创建Hashtable
        Hashtable<String, Integer> table = new Hashtable<>();
        
        // 添加元素
        table.put("A", 1);
        table.put("B", 2);
        
        // 线程安全操作
        synchronized (table) {
            for (Map.Entry<String, Integer> entry : table.entrySet()) {
                System.out.println(entry.getKey() + ": " + entry.getValue());
            }
        }
    }
}
```

## 3.3 集合性能优化

### 选择合适的集合类型

1. **频繁查询**：使用ArrayList或HashMap
2. **频繁插入/删除**：使用LinkedList
3. **需要排序**：使用TreeMap或TreeSet
4. **需要保持插入顺序**：使用LinkedHashMap或LinkedHashSet
5. **高并发场景**：使用ConcurrentHashMap或CopyOnWriteArrayList

### 预设集合容量

```java
public class CollectionCapacityOptimization {
    public static void main(String[] args) {
        // 不好的做法：默认容量可能需要多次扩容
        List<String> list1 = new ArrayList<>();
        for (int i = 0; i < 1000; i++) {
            list1.add("item" + i);
        }
        
        // 好的做法：预设容量避免扩容
        List<String> list2 = new ArrayList<>(1000);
        for (int i = 0; i < 1000; i++) {
            list2.add("item" + i);
        }
        
        // HashMap预设容量
        Map<String, Integer> map = new HashMap<>((int) (1000 / 0.75f) + 1);
        for (int i = 0; i < 1000; i++) {
            map.put("key" + i, i);
        }
    }
}
```

### 避免过度包装

```java
public class CollectionWrapperOptimization {
    // 不好的做法：过度包装
    public void badPractice() {
        List<Integer> list = new ArrayList<>();
        for (int i = 0; i < 1000; i++) {
            list.add(Integer.valueOf(i)); // 自动装箱
        }
        
        int sum = 0;
        for (Integer item : list) {
            sum += item.intValue(); // 自动拆箱
        }
    }
    
    // 好的做法：使用基本类型数组
    public void goodPractice() {
        int[] array = new int[1000];
        for (int i = 0; i < 1000; i++) {
            array[i] = i;
        }
        
        int sum = 0;
        for (int item : array) {
            sum += item;
        }
    }
    
    // 或使用专门的基本类型集合库如Trove
    // TIntArrayList intList = new TIntArrayList();
}
```

### 合理使用Stream API

```java
public class StreamOptimization {
    private List<Person> persons = Arrays.asList(
        new Person("Alice", 25),
        new Person("Bob", 30),
        new Person("Charlie", 35)
    );
    
    // 不好的做法：多次遍历
    public void badPractice() {
        List<String> names = persons.stream()
            .filter(p -> p.getAge() > 25)
            .map(Person::getName)
            .collect(Collectors.toList());
        
        long count = persons.stream()
            .filter(p -> p.getAge() > 25)
            .count();
    }
    
    // 好的做法：一次遍历完成多个操作
    public void goodPractice() {
        Map<String, Long> result = persons.stream()
            .filter(p -> p.getAge() > 25)
            .collect(Collectors.teeing(
                Collectors.mapping(Person::getName, Collectors.toList()),
                Collectors.counting(),
                (names, count) -> {
                    Map<String, Long> map = new HashMap<>();
                    map.put("names", (Long) (Object) names);
                    map.put("count", count);
                    return map;
                }
            ));
    }
    
    // 或者使用传统循环
    public void traditionalLoop() {
        List<String> names = new ArrayList<>();
        int count = 0;
        
        for (Person person : persons) {
            if (person.getAge() > 25) {
                names.add(person.getName());
                count++;
            }
        }
    }
}

class Person {
    private String name;
    private int age;
    
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public String getName() { return name; }
    public int getAge() { return age; }
}
```

### 集合工具类的使用

```java
public class CollectionUtilsDemo {
    public static void main(String[] args) {
        List<String> list1 = Arrays.asList("A", "B", "C");
        List<String> list2 = Arrays.asList("B", "C", "D");
        
        // 求交集
        Set<String> intersection = new HashSet<>(list1);
        intersection.retainAll(list2);
        System.out.println("交集: " + intersection); // [B, C]
        
        // 求并集
        Set<String> union = new HashSet<>(list1);
        union.addAll(list2);
        System.out.println("并集: " + union); // [A, B, C, D]
        
        // 求差集
        Set<String> difference = new HashSet<>(list1);
        difference.removeAll(list2);
        System.out.println("差集: " + difference); // [A]
        
        // 使用Collections工具类
        List<String> list = new ArrayList<>(Arrays.asList("C", "A", "B"));
        Collections.sort(list); // 排序
        System.out.println(list); // [A, B, C]
        
        Collections.reverse(list); // 反转
        System.out.println(list); // [C, B, A]
        
        Collections.shuffle(list); // 随机打乱
        System.out.println(list);
    }
}
```