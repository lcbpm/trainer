# 7. 分布式系统

## 目录
- [7.1 微服务架构](#71-微服务架构)
- [7.2 分布式事务](#72-分布式事务)
- [7.3 消息队列](#73-消息队列)

---

## 7.1 微服务架构

**Q: 微服务的优缺点？**

**优点**：
- 技术栈灵活
- 独立部署和扩展
- 故障隔离
- 团队独立开发

**缺点**：
- 分布式复杂性
- 服务间通信成本
- 数据一致性挑战
- 运维复杂度增加

## 7.2 分布式事务

**Q: 分布式事务解决方案？**
- **2PC（两阶段提交）**：强一致性，性能较差
- **TCC（Try-Confirm-Cancel）**：业务补偿机制
- **Saga模式**：长事务拆分，本地事务 + 补偿
- **最终一致性**：基于消息的异步处理

### 分布式事务详细实现案例

**1. 2PC（两阶段提交）分布式实现示例**

```java
// 分布式事务协调器（运行在独立的协调器节点）
@RestController
@RequestMapping("/transaction-coordinator")
public class DistributedTransactionCoordinator {
    
    @Autowired
    private ParticipantRegistry participantRegistry;
    
    @Autowired
    private RestTemplate restTemplate;
    
    @Autowired
    private TransactionLogService transactionLogService;
    
    // 分布式事务入口
    @PostMapping("/execute")
    public ResponseEntity<TransactionResult> executeDistributedTransaction(
            @RequestBody DistributedTransactionRequest request) {
        
        String transactionId = UUID.randomUUID().toString();
        
        // 记录事务开始
        transactionLogService.logTransactionStart(transactionId, request);
        
        try {
            // 获取所有分布式服务节点
            List<ParticipantNode> participants = participantRegistry
                .getParticipants(request.getTransactionType());
            
            // 第一阶段：向所有分布式节点发送prepare请求
            boolean allPrepared = executeDistributedPreparePhase(transactionId, participants, request);
            
            if (allPrepared) {
                // 第二阶段：向所有节点发送commit请求
                boolean allCommitted = executeDistributedCommitPhase(transactionId, participants);
                transactionLogService.logTransactionCommit(transactionId);
                return ResponseEntity.ok(TransactionResult.success(transactionId));
            } else {
                // 第二阶段：向所有节点发送rollback请求
                executeDistributedRollbackPhase(transactionId, participants);
                transactionLogService.logTransactionRollback(transactionId);
                return ResponseEntity.ok(TransactionResult.failure(transactionId, "Prepare phase failed"));
            }
        } catch (Exception e) {
            // 异常情况下执行分布式回滚
            executeDistributedRollbackPhase(transactionId, 
                participantRegistry.getParticipants(request.getTransactionType()));
            transactionLogService.logTransactionError(transactionId, e.getMessage());
            return ResponseEntity.status(500)
                .body(TransactionResult.error(transactionId, e.getMessage()));
        }
    }
    
    // 分布式Prepare阶段
    private boolean executeDistributedPreparePhase(String transactionId, 
                                                   List<ParticipantNode> participants,
                                                   DistributedTransactionRequest request) {
        
        List<CompletableFuture<Boolean>> prepareFutures = new ArrayList<>();
        
        // 并发向所有分布式节点发送prepare请求
        for (ParticipantNode participant : participants) {
            CompletableFuture<Boolean> future = CompletableFuture.supplyAsync(() -> {
                try {
                    // 网络调用远程服务的prepare接口
                    String url = participant.getBaseUrl() + "/transaction/prepare";
                    PrepareRequest prepareRequest = new PrepareRequest(transactionId, request.getData());
                    
                    ResponseEntity<PrepareResponse> response = restTemplate.postForEntity(
                        url, prepareRequest, PrepareResponse.class);
                    
                    return response.getBody() != null && response.getBody().isSuccess();
                } catch (Exception e) {
                    log.error("Prepare failed for participant: {} at {}", 
                        participant.getServiceName(), participant.getBaseUrl(), e);
                    return false;
                }
            });
            prepareFutures.add(future);
        }
        
        // 等待所有远程调用完成
        try {
            return prepareFutures.stream()
                .map(CompletableFuture::join)
                .allMatch(result -> result);
        } catch (Exception e) {
            log.error("Prepare phase failed", e);
            return false;
        }
    }
    
    // 分布式Commit阶段
    private boolean executeDistributedCommitPhase(String transactionId, 
                                                 List<ParticipantNode> participants) {
        List<CompletableFuture<Boolean>> commitFutures = new ArrayList<>();
        
        for (ParticipantNode participant : participants) {
            CompletableFuture<Boolean> future = CompletableFuture.supplyAsync(() -> {
                try {
                    // 网络调用远程服务的commit接口
                    String url = participant.getBaseUrl() + "/transaction/commit";
                    CommitRequest commitRequest = new CommitRequest(transactionId);
                    
                    ResponseEntity<CommitResponse> response = restTemplate.postForEntity(
                        url, commitRequest, CommitResponse.class);
                    
                    return response.getBody() != null && response.getBody().isSuccess();
                } catch (Exception e) {
                    log.error("Commit failed for participant: {} at {}", 
                        participant.getServiceName(), participant.getBaseUrl(), e);
                    // commit失败需要重试机制
                    scheduleRetryCommit(participant, transactionId);
                    return false;
                }
            });
            commitFutures.add(future);
        }
        
        // 等待所有分布式节点commit完成
        try {
            return commitFutures.stream()
                .map(CompletableFuture::join)
                .allMatch(result -> result);
        } catch (Exception e) {
            log.error("Commit phase failed", e);
            return false;
        }
    }
    
    // 分布式Rollback阶段
    private void executeDistributedRollbackPhase(String transactionId, 
                                                List<ParticipantNode> participants) {
        // 并发向所有分布式节点发送rollback请求
        participants.parallelStream().forEach(participant -> {
            try {
                String url = participant.getBaseUrl() + "/transaction/rollback";
                RollbackRequest rollbackRequest = new RollbackRequest(transactionId);
                
                ResponseEntity<RollbackResponse> response = restTemplate.postForEntity(
                    url, rollbackRequest, RollbackResponse.class);
                
                if (response.getBody() == null || !response.getBody().isSuccess()) {
                    log.error("Rollback failed for participant: {} at {}", 
                        participant.getServiceName(), participant.getBaseUrl());
                }
            } catch (Exception e) {
                log.error("Rollback failed for participant: {} at {}", 
                    participant.getServiceName(), participant.getBaseUrl(), e);
            }
        });
    }
}

// 参与者节点信息（代表不同的分布式服务）
@Entity
@Table(name = "participant_nodes")
public class ParticipantNode {
    private String serviceId;
    private String serviceName;
    private String baseUrl;  // 远程服务地址，如：http://order-service:8081
    private String ipAddress;
    private int port;
    private boolean isActive;
    
    // getters and setters...
}

// 参与者注册中心（服务发现）
@Service
public class ParticipantRegistry {
    
    @Autowired
    private ParticipantNodeRepository nodeRepository;
    
    @Autowired
    private EurekaClient eurekaClient;  // 或者使用Consul、Nacos等
    
    public List<ParticipantNode> getParticipants(String transactionType) {
        // 根据事务类型获取相关的分布式服务节点
        switch (transactionType) {
            case "ORDER_TRANSACTION":
                return Arrays.asList(
                    findServiceNode("order-service"),
                    findServiceNode("inventory-service"),
                    findServiceNode("payment-service")
                );
            case "TRANSFER_TRANSACTION":
                return Arrays.asList(
                    findServiceNode("account-service"),
                    findServiceNode("audit-service")
                );
            default:
                return nodeRepository.findByIsActiveTrue();
        }
    }
    
    private ParticipantNode findServiceNode(String serviceName) {
        // 从服务注册中心获取服务实例
        List<InstanceInfo> instances = eurekaClient.getInstancesByVipAddress(serviceName, false);
        
        if (!instances.isEmpty()) {
            InstanceInfo instance = instances.get(0);  // 简化处理，实际可以负载均衡
            return new ParticipantNode()
                .setServiceName(serviceName)
                .setBaseUrl("http://" + instance.getHostName() + ":" + instance.getPort())
                .setIpAddress(instance.getIPAddr())
                .setPort(instance.getPort())
                .setActive(true);
        }
        
        throw new ServiceNotFoundException("Service not found: " + serviceName);
    }
}
```

```java
// 订单服务（独立的微服务，运行在不同的JVM/容器中）
@RestController
@RequestMapping("/transaction")
public class OrderServiceParticipant {
    
    @Autowired
    private OrderService orderService;
    
    @Autowired
    private TransactionResourceManager resourceManager;
    
    // 处理来自协调器的prepare请求
    @PostMapping("/prepare")
    public ResponseEntity<PrepareResponse> prepare(@RequestBody PrepareRequest request) {
        String transactionId = request.getTransactionId();
        
        try {
            log.info("[OrderService] Received prepare request for transaction: {}", transactionId);
            
            // 执行业务逻辑检查和资源预留
            OrderData orderData = (OrderData) request.getData();
            
            // 1. 验证订单数据
            if (!orderService.validateOrder(orderData)) {
                return ResponseEntity.ok(PrepareResponse.failure("订单数据无效"));
            }
            
            // 2. 预留资源（但不真正执行业务操作）
            boolean resourceReserved = resourceManager.reserveResources(transactionId, orderData);
            
            if (resourceReserved) {
                log.info("[OrderService] Prepare successful for transaction: {}", transactionId);
                return ResponseEntity.ok(PrepareResponse.success());
            } else {
                log.warn("[OrderService] Prepare failed - resource reservation failed for transaction: {}", transactionId);
                return ResponseEntity.ok(PrepareResponse.failure("资源预留失败"));
            }
        } catch (Exception e) {
            log.error("[OrderService] Prepare error for transaction: {}", transactionId, e);
            return ResponseEntity.status(500).body(PrepareResponse.error(e.getMessage()));
        }
    }
    
    // 处理来自协调器的commit请求
    @PostMapping("/commit")
    public ResponseEntity<CommitResponse> commit(@RequestBody CommitRequest request) {
        String transactionId = request.getTransactionId();
        
        try {
            log.info("[OrderService] Received commit request for transaction: {}", transactionId);
            
            // 真正执行业务操作
            boolean committed = resourceManager.commitTransaction(transactionId);
            
            if (committed) {
                log.info("[OrderService] Commit successful for transaction: {}", transactionId);
                return ResponseEntity.ok(CommitResponse.success());
            } else {
                log.error("[OrderService] Commit failed for transaction: {}", transactionId);
                return ResponseEntity.ok(CommitResponse.failure("提交失败"));
            }
        } catch (Exception e) {
            log.error("[OrderService] Commit error for transaction: {}", transactionId, e);
            return ResponseEntity.status(500).body(CommitResponse.error(e.getMessage()));
        }
    }
    
    // 处理来自协调器的rollback请求
    @PostMapping("/rollback")
    public ResponseEntity<RollbackResponse> rollback(@RequestBody RollbackRequest request) {
        String transactionId = request.getTransactionId();
        
        try {
            log.info("[OrderService] Received rollback request for transaction: {}", transactionId);
            
            // 释放预留的资源
            boolean rolledBack = resourceManager.rollbackTransaction(transactionId);
            
            if (rolledBack) {
                log.info("[OrderService] Rollback successful for transaction: {}", transactionId);
                return ResponseEntity.ok(RollbackResponse.success());
            } else {
                log.error("[OrderService] Rollback failed for transaction: {}", transactionId);
                return ResponseEntity.ok(RollbackResponse.failure("回滚失败"));
            }
        } catch (Exception e) {
            log.error("[OrderService] Rollback error for transaction: {}", transactionId, e);
            return ResponseEntity.status(500).body(RollbackResponse.error(e.getMessage()));
        }
    }
}
```

**2. TCC（Try-Confirm-Cancel）分布式实现**

```java
// TCC分布式事务协调器
@RestController
@RequestMapping("/tcc-coordinator")
public class DistributedTCCCoordinator {
    
    @Autowired
    private TCCParticipantRegistry participantRegistry;
    
    @Autowired
    private RestTemplate restTemplate;
    
    @PostMapping("/execute")
    public ResponseEntity<TCCExecutionResult> executeTCC(@RequestBody TCCRequest request) {
        String transactionId = UUID.randomUUID().toString();
        
        try {
            List<TCCParticipantNode> participants = participantRegistry
                .getTCCParticipants(request.getBusinessType());
            
            // Try阶段：所有参与者尝试执行业务操作
            boolean allTrySuccess = executeTryPhase(transactionId, participants, request);
            
            if (allTrySuccess) {
                // Confirm阶段：所有参与者确认执行
                boolean allConfirmSuccess = executeConfirmPhase(transactionId, participants);
                return ResponseEntity.ok(TCCExecutionResult.success(transactionId));
            } else {
                // Cancel阶段：所有参与者取消执行
                executeCancelPhase(transactionId, participants);
                return ResponseEntity.ok(TCCExecutionResult.failure(transactionId, "Try phase failed"));
            }
            
        } catch (Exception e) {
            // 异常时执行Cancel
            executeCancelPhase(transactionId, 
                participantRegistry.getTCCParticipants(request.getBusinessType()));
            return ResponseEntity.status(500)
                .body(TCCExecutionResult.error(transactionId, e.getMessage()));
        }
    }
    
    // Try阶段执行
    private boolean executeTryPhase(String transactionId, 
                                   List<TCCParticipantNode> participants,
                                   TCCRequest request) {
        
        List<CompletableFuture<Boolean>> tryFutures = new ArrayList<>();
        
        // 并发调用所有分布式服务的try接口
        for (TCCParticipantNode participant : participants) {
            CompletableFuture<Boolean> future = CompletableFuture.supplyAsync(() -> {
                try {
                    String url = participant.getBaseUrl() + "/tcc/try";
                    TCCTryRequest tryRequest = new TCCTryRequest(transactionId, request.getBusinessContext());
                    
                    ResponseEntity<TCCTryResponse> response = restTemplate.postForEntity(
                        url, tryRequest, TCCTryResponse.class);
                    
                    return response.getBody() != null && response.getBody().isSuccess();
                } catch (Exception e) {
                    log.error("[TCC-Coordinator] Try failed for participant: {} at {}", 
                        participant.getServiceName(), participant.getBaseUrl(), e);
                    return false;
                }
            });
            tryFutures.add(future);
        }
        
        return tryFutures.stream()
            .map(CompletableFuture::join)
            .allMatch(result -> result);
    }
    
    // 其他方法类似...
}

// 库存服务TCC实现（独立微服务）
@RestController
@RequestMapping("/tcc")
public class DistributedInventoryServiceTCC {
    
    @Autowired
    private InventoryService inventoryService;
    
    @PostMapping("/try")
    public ResponseEntity<TCCTryResponse> tryExecute(@RequestBody TCCTryRequest request) {
        String transactionId = request.getTransactionId();
        
        try {
            log.info("[InventoryService-TCC] Received try request for transaction: {}", transactionId);
            
            BusinessContext context = request.getBusinessContext();
            Long productId = context.getProductId();
            Integer quantity = context.getQuantity();
            
            // Try阶段：检查库存并冻结
            boolean hasStock = inventoryService.checkAvailableStock(productId, quantity);
            
            if (hasStock) {
                boolean frozen = inventoryService.freezeInventory(transactionId, productId, quantity);
                if (frozen) {
                    log.info("[InventoryService-TCC] Try successful for transaction: {}", transactionId);
                    return ResponseEntity.ok(TCCTryResponse.success("库存冻结成功"));
                }
            }
            
            return ResponseEntity.ok(TCCTryResponse.failure("库存不足"));
            
        } catch (Exception e) {
            log.error("[InventoryService-TCC] Try error for transaction: {}", transactionId, e);
            return ResponseEntity.status(500).body(TCCTryResponse.error(e.getMessage()));
        }
    }
    
    @PostMapping("/confirm")
    public ResponseEntity<TCCConfirmResponse> confirm(@RequestBody TCCConfirmRequest request) {
        // 确认扣减库存逻辑...
        return ResponseEntity.ok(TCCConfirmResponse.success());
    }
    
    @PostMapping("/cancel")
    public ResponseEntity<TCCCancelResponse> cancel(@RequestBody TCCCancelRequest request) {
        // 释放冻结库存逻辑...
        return ResponseEntity.ok(TCCCancelResponse.success());
    }
}
```

**3. Saga模式分布式实现**

```java
// Saga分布式编排器（独立服务）
@RestController
@RequestMapping("/saga-orchestrator")
public class DistributedSagaOrchestrator {
    
    @Autowired
    private SagaStepRegistry stepRegistry;
    
    @Autowired
    private RestTemplate restTemplate;
    
    @PostMapping("/execute")
    public ResponseEntity<SagaExecutionResult> executeSaga(@RequestBody SagaRequest request) {
        String sagaId = UUID.randomUUID().toString();
        
        try {
            // 获取分布式步骤定义
            List<DistributedSagaStep> steps = stepRegistry.getSagaSteps(request.getBusinessType());
            
            // 顺序执行所有分布式步骤
            for (int i = 0; i < steps.size(); i++) {
                DistributedSagaStep step = steps.get(i);
                
                try {
                    // 调用远程服务执行步骤
                    StepResult result = executeDistributedStep(sagaId, step, request.getSagaContext());
                    
                    if (!result.isSuccess()) {
                        // 步骤失败，执行分布式补偿
                        executeDistributedCompensation(sagaId, steps, i);
                        return ResponseEntity.ok(SagaExecutionResult.failure(sagaId, "Step failed"));
                    }
                } catch (Exception e) {
                    executeDistributedCompensation(sagaId, steps, i);
                    return ResponseEntity.status(500)
                        .body(SagaExecutionResult.error(sagaId, e.getMessage()));
                }
            }
            
            return ResponseEntity.ok(SagaExecutionResult.success(sagaId));
            
        } catch (Exception e) {
            return ResponseEntity.status(500)
                .body(SagaExecutionResult.error(sagaId, e.getMessage()));
        }
    }
    
    // 执行分布式步骤
    private StepResult executeDistributedStep(String sagaId, DistributedSagaStep step, SagaContext context) {
        try {
            String url = step.getServiceUrl() + step.getExecutionEndpoint();
            SagaStepRequest stepRequest = new SagaStepRequest(sagaId, context);
            
            ResponseEntity<SagaStepResponse> response = restTemplate.postForEntity(
                url, stepRequest, SagaStepResponse.class);
            
            return response.getBody() != null && response.getBody().isSuccess() ?
                StepResult.success(response.getBody().getData()) :
                StepResult.failure("Step execution failed");
            
        } catch (Exception e) {
            return StepResult.failure(e.getMessage());
        }
    }
    
    // 执行分布式补偿
    private void executeDistributedCompensation(String sagaId, List<DistributedSagaStep> steps, int failedStepIndex) {
        // 按相反顺序调用远程服务的补偿接口
        for (int i = failedStepIndex - 1; i >= 0; i--) {
            DistributedSagaStep step = steps.get(i);
            try {
                String url = step.getServiceUrl() + step.getCompensationEndpoint();
                SagaCompensationRequest compensationRequest = new SagaCompensationRequest(sagaId);
                
                restTemplate.postForEntity(url, compensationRequest, SagaCompensationResponse.class);
            } catch (Exception e) {
                log.error("Compensation failed for step: {} saga: {}", step.getStepName(), sagaId, e);
            }
        }
    }
}

// 订单服务Saga步骤（独立微服务）
@RestController
@RequestMapping("/saga")
public class OrderServiceSagaStep {
    
    @Autowired
    private OrderService orderService;
    
    @PostMapping("/create-order")
    public ResponseEntity<SagaStepResponse> createOrder(@RequestBody SagaStepRequest request) {
        try {
            SagaContext context = request.getContext();
            Order order = orderService.createOrder(context.getOrderRequest());
            
            return ResponseEntity.ok(SagaStepResponse.success(order.getId()));
        } catch (Exception e) {
            return ResponseEntity.ok(SagaStepResponse.failure(e.getMessage()));
        }
    }
    
    @PostMapping("/compensate-create-order")
    public ResponseEntity<SagaCompensationResponse> compensateCreateOrder(
            @RequestBody SagaCompensationRequest request) {
        try {
            // 补偿逻辑：取消订单
            Long orderId = getOrderIdFromSaga(request.getSagaId());
            if (orderId != null) {
                orderService.cancelOrder(orderId);
            }
            return ResponseEntity.ok(SagaCompensationResponse.success());
        } catch (Exception e) {
            return ResponseEntity.ok(SagaCompensationResponse.failure(e.getMessage()));
        }
    }
}
```

**4. 基于消息的分布式最终一致性**

```java
// 分布式事件发布服务（独立服务）
@RestController
@RequestMapping("/distributed-events")
public class DistributedEventPublisher {
    
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    @Autowired
    private OutboxEventRepository outboxRepository;
    
    // 本地事务 + 分布式消息发送（Outbox模式）
    @PostMapping("/create-order")
    @Transactional
    public ResponseEntity<EventPublishResult> createOrderWithDistributedEvents(
            @RequestBody CreateOrderRequest request) {
        
        try {
            // 1. 执行本地业务操作
            Order order = orderService.createOrder(request);
            
            // 2. 在同一事务中保存要发送的分布式事件
            List<OutboxEvent> events = createDistributedEvents(order);
            outboxRepository.saveAll(events);
            
            return ResponseEntity.ok(EventPublishResult.success(order.getId(), events.size()));
            
        } catch (Exception e) {
            return ResponseEntity.status(500)
                .body(EventPublishResult.error(e.getMessage()));
        }
    }
    
    // 创建分布式事件
    private List<OutboxEvent> createDistributedEvents(Order order) {
        List<OutboxEvent> events = new ArrayList<>();
        
        // 库存服务事件
        events.add(new OutboxEvent()
            .setEventType("ORDER_CREATED_FOR_INVENTORY")
            .setTargetService("inventory-service")
            .setRoutingKey("inventory.order.created")
            .setPayload(JsonUtils.toJson(new InventoryReservationEvent(order)))
            .setStatus(EventStatus.PENDING));
        
        // 支付服务事件
        events.add(new OutboxEvent()
            .setEventType("ORDER_CREATED_FOR_PAYMENT")
            .setTargetService("payment-service")
            .setRoutingKey("payment.order.created")
            .setPayload(JsonUtils.toJson(new PaymentProcessEvent(order)))
            .setStatus(EventStatus.PENDING));
        
        return events;
    }
    
    // 分布式事件发送器（定时任务）
    @Scheduled(fixedDelay = 2000)
    public void publishPendingDistributedEvents() {
        List<OutboxEvent> pendingEvents = outboxRepository
            .findByStatusOrderByCreatedTimeAsc(EventStatus.PENDING);
        
        for (OutboxEvent event : pendingEvents) {
            try {
                // 发送消息到对应的分布式服务队列
                rabbitTemplate.convertAndSend(
                    "distributed.transaction.exchange",
                    event.getRoutingKey(),
                    event.getPayload()
                );
                
                // 标记为已发送
                event.setStatus(EventStatus.SENT);
                outboxRepository.save(event);
                
            } catch (Exception e) {
                log.error("Failed to publish distributed event: eventId={}", event.getId(), e);
                event.setRetryCount(event.getRetryCount() + 1);
                if (event.getRetryCount() > 3) {
                    event.setStatus(EventStatus.FAILED);
                }
                outboxRepository.save(event);
            }
        }
    }
}

// 库存服务消息消费者（独立微服务）
@Component
public class DistributedInventoryMessageConsumer {
    
    @Autowired
    private InventoryService inventoryService;
    
    @RabbitListener(queues = "inventory.order.created.queue")
    public void handleOrderCreatedForInventory(@Payload String message) {
        try {
            InventoryReservationEvent event = JsonUtils.fromJson(message, InventoryReservationEvent.class);
            
            // 处理库存预留
            boolean reserved = inventoryService.reserveInventoryForOrder(
                event.getProductId(), event.getQuantity(), event.getOrderId());
            
            if (reserved) {
                // 成功后发送确认事件到订单服务
                publishInventoryReservedEvent(event.getOrderId());
            } else {
                // 库存不足，发送失败事件
                publishInventoryReservationFailedEvent(event.getOrderId());
            }
            
        } catch (Exception e) {
            log.error("Failed to handle order created event", e);
            // 实现重试或死信队列处理
            throw new MessageProcessingException("库存处理失败", e);
        }
    }
    
    private void publishInventoryReservedEvent(Long orderId) {
        // 发送库存预留成功事件到订单服务
    }
    
    private void publishInventoryReservationFailedEvent(Long orderId) {
        // 发送库存预留失败事件
    }
}
```

**分布式事务选择指南：**

| 模式 | 一致性 | 性能 | 复杂度 | 适用场景 |
|------|--------|------|--------|----------|
| 2PC | 强一致性 | 低 | 中等 | 金融、核心业务 |
| TCC | 强一致性 | 中等 | 高 | 对一致性要求高的业务 |
| Saga | 最终一致性 | 高 | 中等 | 长流程业务 |
| 消息队列 | 最终一致性 | 高 | 低 | 大部分业务场景 |

## 7.3 消息队列

**Q: 消息队列的作用？**
- 解耦：降低系统间依赖
- 异步：提高系统响应速度
- 削峰：处理突发流量
- 持久化：保证消息不丢失