Go 通过轻量级 runtime、goroutine 小栈（2KB 起，按需扩展）、逃逸分析（尽量把对象放栈而不是堆）、以及 arena/span 内存分配模型，实现了高并发和低内存占用。相比 Java，Go 的并发开销更小、内存利用率更高，适合微服务和云原生场景。


| 维度       | Go                                    | Java                           | 说明                                     |
| -------- | ------------------------------------- | ------------------------------ | -------------------------------------- |
| **运行方式** | **AOT 编译** → 直接生成本地机器码，可独立运行          | **JVM 字节码 + JIT** → 运行时解释/编译   | Go 不需要 JVM，启动快，部署简单                    |
| **启动速度** | 快，几毫秒                                 | 慢，需要类加载 + JIT 热身               | 小服务/微服务场景优势明显                          |
| **并发模型** | **goroutine + M\:N 调度**，轻量级，百万级并发可行   | 线程 1:1 OS 映射（虚拟线程 Loom 还在发展）   | Go 切换开销小，内存占用低                         |
| **栈大小**  | 初始 2KB，可按需扩展                          | 线程默认 1MB                       | Go 小栈支撑高并发                             |
| **逃逸分析** | 编译期决定对象栈/堆分配                          | JIT 热身后优化少量对象到栈                | Go 大量临时对象栈上分配，减少 GC 压力                 |
| **堆管理**  | **arena/span + 小对象池化**，小对象连续分配        | 分代堆（年轻代/老年代/元空间）               | Go 小对象 cache-friendly，分配快，碎片少          |
| **GC**   | 并发三色标记，低延迟，调优简单                       | G1/ZGC/Shenandoah 等复杂 GC，适合大堆  | Go 延迟低，适合延迟敏感服务                        |
| **数据结构** | struct 紧凑、slice/map 轻量、map bucket 用数组 | 对象有头部信息，HashMap 用链表/红黑树        | Go 内存占用低，CPU cache 命中率高                |
| **内存布局** | map bucket 内部数组连续，span 内存池管理小对象       | HashMap bucket 链表/红黑树分散，堆对象不连续 | Go 内存布局连续 → 访问快；Java 分散 → cache miss 多 |
| **性能特点** | 启动快、并发轻量、低内存开销                        | 启动慢、JIT 优化后吞吐高、适合大对象长生命周期      | 各有适用场景，Go 云原生/微服务优势明显                  |
