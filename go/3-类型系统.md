# 3. 类型系统

## 📋 目录

- [3.1 接口](#31-接口)
- [3.2 反射](#32-反射)
- [3.3 接口和类型系统代码题](#33-接口和类型系统代码题)

---

### 3.1 接口
**Q: 空接口interface{}的底层实现？**
- eface结构：_type和data指针
- 类型断言的性能考虑

**Q: 接口的动态类型和动态值？**
- 类型信息和值信息分别存储
- nil接口的判断机制

### 3.2 反射
**Q: 反射的性能影响和使用场景？**
- Type和Value的获取成本

### 3.3 接口和类型系统代码题

#### 空接口判断
```go
func isNil(x interface{}) bool {
    // 错误的nil判断
    return x == nil
}

func correctNilCheck(x interface{}) bool {
    // 正确的nil判断
    if x == nil {
        return true
    }
    
    v := reflect.ValueOf(x)
    switch v.Kind() {
    case reflect.Chan, reflect.Func, reflect.Interface, 
         reflect.Map, reflect.Ptr, reflect.Slice:
        return v.IsNil()
    default:
        return false
    }
}
```

#### 类型断言性能
```go
// 高频类型断言优化
func processValue(v interface{}) {
    // 使用type switch比多次类型断言效率更高
    switch val := v.(type) {
    case int:
        // 处理int
    case string:
        // 处理string
    case []byte:
        // 处理[]byte
    default:
        // 处理其他类型
    }
}
```