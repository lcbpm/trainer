# 8. 网络编程

## 📋 目录

- [8.1 网络模型](#81-网络模型)
- [8.2 Channel 高级使用模式](#82-channel-高级使用模式)

---

**Q: Go的网络模型和epoll？**
- netpoller的实现
- 异步I/O的处理

**Q: Context的使用和传播？**
- 超时控制和取消机制

#### Go网络编程实战案例

**高性能TCP服务器实现：**
```go
package main

import (
    "context"
    "fmt"
    "log"
    "net"
    "sync"
    "time"
)

// TCP服务器
type TCPServer struct {
    address   string
    listener  net.Listener
    ctx       context.Context
    cancel    context.CancelFunc
    wg        sync.WaitGroup
}

func NewTCPServer(address string) *TCPServer {
    ctx, cancel := context.WithCancel(context.Background())
    return &TCPServer{
        address: address,
        ctx:     ctx,
        cancel:  cancel,
    }
}

func (s *TCPServer) Start() error {
    listener, err := net.Listen("tcp", s.address)
    if err != nil {
        return fmt.Errorf("启动TCP服务器失败: %w", err)
    }
    
    s.listener = listener
    log.Printf("TCP服务器启动，监听地址: %s", s.address)
    
    // 启动连接接受器
    s.wg.Add(1)
    go s.acceptConnections()
    
    return nil
}

func (s *TCPServer) acceptConnections() {
    defer s.wg.Done()
    
    for {
        // 设置接受超时
        if tcpListener, ok := s.listener.(*net.TCPListener); ok {
            tcpListener.SetDeadline(time.Now().Add(1 * time.Second))
        }
        
        conn, err := s.listener.Accept()
        if err != nil {
            select {
            case <-s.ctx.Done():
                return
            default:
                if netErr, ok := err.(net.Error); ok && netErr.Timeout() {
                    continue // 超时是正常的，继续等待
                }
                log.Printf("接受连接失败: %v", err)
                continue
            }
        }
        
        // 为每个连接启动一个goroutine
        s.wg.Add(1)
        go s.handleConnection(conn)
    }
}

func (s *TCPServer) handleConnection(conn net.Conn) {
    defer s.wg.Done()
    defer conn.Close()
    
    log.Printf("新连接来自: %s", conn.RemoteAddr())
    
    // 设置连接超时
    conn.SetReadDeadline(time.Now().Add(30 * time.Second))
    
    buffer := make([]byte, 1024)
    for {
        select {
        case <-s.ctx.Done():
            return
        default:
            n, err := conn.Read(buffer)
            if err != nil {
                log.Printf("读取数据失败: %v", err)
                return
            }
            
            // Echo服务器：将接收到的数据发送回去
            response := fmt.Sprintf("Echo: %s", string(buffer[:n]))
            _, err = conn.Write([]byte(response))
            if err != nil {
                log.Printf("发送响应失败: %v", err)
                return
            }
            
            // 更新读取超时
            conn.SetReadDeadline(time.Now().Add(30 * time.Second))
        }
    }
}

func (s *TCPServer) Stop() error {
    log.Println("停止TCP服务器...")
    
    s.cancel()
    
    if s.listener != nil {
        s.listener.Close()
    }
    
    // 等待所有goroutine结束
    done := make(chan struct{})
    go func() {
        s.wg.Wait()
        close(done)
    }()
    
    select {
    case <-done:
        log.Println("TCP服务器已停止")
    case <-time.After(5 * time.Second):
        log.Println("TCP服务器停止超时")
    }
    
    return nil
}

// Context使用示例
func demonstrateContext() {
    fmt.Println("\n=== Context使用示例 ===")
    
    // 1. 带超时的Context
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel()
    
    // 模拟一个可能超时的操作
    done := make(chan string, 1)
    go func() {
        time.Sleep(1 * time.Second) // 模拟工作
        done <- "工作完成"
    }()
    
    select {
    case result := <-done:
        fmt.Println("结果:", result)
    case <-ctx.Done():
        fmt.Println("操作超时:", ctx.Err())
    }
    
    // 2. 带取消的Context
    ctx2, cancel2 := context.WithCancel(context.Background())
    
    go func() {
        for {
            select {
            case <-ctx2.Done():
                fmt.Println("工作被取消")
                return
            default:
                fmt.Println("正在工作...")
                time.Sleep(500 * time.Millisecond)
            }
        }
    }()
    
    time.Sleep(1500 * time.Millisecond)
    cancel2() // 取消操作
    time.Sleep(100 * time.Millisecond)
}

func main() {
    // 演示Context使用
    demonstrateContext()
    
    // 启动TCP服务器
    server := NewTCPServer(":8080")
    
    if err := server.Start(); err != nil {
        log.Fatal(err)
    }
    
    // 运行一段时间后停止
    time.Sleep(10 * time.Second)
    server.Stop()
}
```

### 8.2 Channel 高级使用模式

#### 扇入扇出模式
```go
// 扇出 - 一个输入分发到多个worker
func fanOut(in <-chan int, workers int) []<-chan int {
    outs := make([]<-chan int, workers)
    for i := 0; i < workers; i++ {
        out := make(chan int)
        outs[i] = out
        
        go func(out chan<- int) {
            defer close(out)
            for val := range in {
                out <- process(val)
            }
        }(out)
    }
    return outs
}

// 扇入 - 多个输入合并到一个输出
func fanIn(ins ...<-chan int) <-chan int {
    out := make(chan int)
    var wg sync.WaitGroup
    
    for _, in := range ins {
        wg.Add(1)
        go func(in <-chan int) {
            defer wg.Done()
            for val := range in {
                out <- val
            }
        }(in)
    }
    
    go func() {
        wg.Wait()
        close(out)
    }()
    
    return out
}
```

#### 超时控制模式
```go
func timeoutOperation(timeout time.Duration) error {
    done := make(chan error, 1)
    
    go func() {
        // 执行耗时操作
        done <- longRunningOperation()
    }()
    
    select {
    case err := <-done:
        return err
    case <-time.After(timeout):
        return errors.New("操作超时")
    }
}
```

