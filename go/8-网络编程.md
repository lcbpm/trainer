# 8. ç½‘ç»œç¼–ç¨‹

## ğŸ“‹ ç›®å½•

- [8.1 ç½‘ç»œæ¨¡å‹](#81-ç½‘ç»œæ¨¡å‹)
- [8.2 Channel é«˜çº§ä½¿ç”¨æ¨¡å¼](#82-channel-é«˜çº§ä½¿ç”¨æ¨¡å¼)

---

**Q: Goçš„ç½‘ç»œæ¨¡å‹å’Œepollï¼Ÿ**
- netpollerçš„å®ç°
- å¼‚æ­¥I/Oçš„å¤„ç†

**Q: Contextçš„ä½¿ç”¨å’Œä¼ æ’­ï¼Ÿ**
- è¶…æ—¶æ§åˆ¶å’Œå–æ¶ˆæœºåˆ¶

#### Goç½‘ç»œç¼–ç¨‹å®æˆ˜æ¡ˆä¾‹

**é«˜æ€§èƒ½TCPæœåŠ¡å™¨å®ç°ï¼š**
```go
package main

import (
    "context"
    "fmt"
    "log"
    "net"
    "sync"
    "time"
)

// TCPæœåŠ¡å™¨
type TCPServer struct {
    address   string
    listener  net.Listener
    ctx       context.Context
    cancel    context.CancelFunc
    wg        sync.WaitGroup
}

func NewTCPServer(address string) *TCPServer {
    ctx, cancel := context.WithCancel(context.Background())
    return &TCPServer{
        address: address,
        ctx:     ctx,
        cancel:  cancel,
    }
}

func (s *TCPServer) Start() error {
    listener, err := net.Listen("tcp", s.address)
    if err != nil {
        return fmt.Errorf("å¯åŠ¨TCPæœåŠ¡å™¨å¤±è´¥: %w", err)
    }
    
    s.listener = listener
    log.Printf("TCPæœåŠ¡å™¨å¯åŠ¨ï¼Œç›‘å¬åœ°å€: %s", s.address)
    
    // å¯åŠ¨è¿æ¥æ¥å—å™¨
    s.wg.Add(1)
    go s.acceptConnections()
    
    return nil
}

func (s *TCPServer) acceptConnections() {
    defer s.wg.Done()
    
    for {
        // è®¾ç½®æ¥å—è¶…æ—¶
        if tcpListener, ok := s.listener.(*net.TCPListener); ok {
            tcpListener.SetDeadline(time.Now().Add(1 * time.Second))
        }
        
        conn, err := s.listener.Accept()
        if err != nil {
            select {
            case <-s.ctx.Done():
                return
            default:
                if netErr, ok := err.(net.Error); ok && netErr.Timeout() {
                    continue // è¶…æ—¶æ˜¯æ­£å¸¸çš„ï¼Œç»§ç»­ç­‰å¾…
                }
                log.Printf("æ¥å—è¿æ¥å¤±è´¥: %v", err)
                continue
            }
        }
        
        // ä¸ºæ¯ä¸ªè¿æ¥å¯åŠ¨ä¸€ä¸ªgoroutine
        s.wg.Add(1)
        go s.handleConnection(conn)
    }
}

func (s *TCPServer) handleConnection(conn net.Conn) {
    defer s.wg.Done()
    defer conn.Close()
    
    log.Printf("æ–°è¿æ¥æ¥è‡ª: %s", conn.RemoteAddr())
    
    // è®¾ç½®è¿æ¥è¶…æ—¶
    conn.SetReadDeadline(time.Now().Add(30 * time.Second))
    
    buffer := make([]byte, 1024)
    for {
        select {
        case <-s.ctx.Done():
            return
        default:
            n, err := conn.Read(buffer)
            if err != nil {
                log.Printf("è¯»å–æ•°æ®å¤±è´¥: %v", err)
                return
            }
            
            // EchoæœåŠ¡å™¨ï¼šå°†æ¥æ”¶åˆ°çš„æ•°æ®å‘é€å›å»
            response := fmt.Sprintf("Echo: %s", string(buffer[:n]))
            _, err = conn.Write([]byte(response))
            if err != nil {
                log.Printf("å‘é€å“åº”å¤±è´¥: %v", err)
                return
            }
            
            // æ›´æ–°è¯»å–è¶…æ—¶
            conn.SetReadDeadline(time.Now().Add(30 * time.Second))
        }
    }
}

func (s *TCPServer) Stop() error {
    log.Println("åœæ­¢TCPæœåŠ¡å™¨...")
    
    s.cancel()
    
    if s.listener != nil {
        s.listener.Close()
    }
    
    // ç­‰å¾…æ‰€æœ‰goroutineç»“æŸ
    done := make(chan struct{})
    go func() {
        s.wg.Wait()
        close(done)
    }()
    
    select {
    case <-done:
        log.Println("TCPæœåŠ¡å™¨å·²åœæ­¢")
    case <-time.After(5 * time.Second):
        log.Println("TCPæœåŠ¡å™¨åœæ­¢è¶…æ—¶")
    }
    
    return nil
}

// Contextä½¿ç”¨ç¤ºä¾‹
func demonstrateContext() {
    fmt.Println("\n=== Contextä½¿ç”¨ç¤ºä¾‹ ===")
    
    // 1. å¸¦è¶…æ—¶çš„Context
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel()
    
    // æ¨¡æ‹Ÿä¸€ä¸ªå¯èƒ½è¶…æ—¶çš„æ“ä½œ
    done := make(chan string, 1)
    go func() {
        time.Sleep(1 * time.Second) // æ¨¡æ‹Ÿå·¥ä½œ
        done <- "å·¥ä½œå®Œæˆ"
    }()
    
    select {
    case result := <-done:
        fmt.Println("ç»“æœ:", result)
    case <-ctx.Done():
        fmt.Println("æ“ä½œè¶…æ—¶:", ctx.Err())
    }
    
    // 2. å¸¦å–æ¶ˆçš„Context
    ctx2, cancel2 := context.WithCancel(context.Background())
    
    go func() {
        for {
            select {
            case <-ctx2.Done():
                fmt.Println("å·¥ä½œè¢«å–æ¶ˆ")
                return
            default:
                fmt.Println("æ­£åœ¨å·¥ä½œ...")
                time.Sleep(500 * time.Millisecond)
            }
        }
    }()
    
    time.Sleep(1500 * time.Millisecond)
    cancel2() // å–æ¶ˆæ“ä½œ
    time.Sleep(100 * time.Millisecond)
}

func main() {
    // æ¼”ç¤ºContextä½¿ç”¨
    demonstrateContext()
    
    // å¯åŠ¨TCPæœåŠ¡å™¨
    server := NewTCPServer(":8080")
    
    if err := server.Start(); err != nil {
        log.Fatal(err)
    }
    
    // è¿è¡Œä¸€æ®µæ—¶é—´ååœæ­¢
    time.Sleep(10 * time.Second)
    server.Stop()
}
```

### 8.2 Channel é«˜çº§ä½¿ç”¨æ¨¡å¼

#### æ‰‡å…¥æ‰‡å‡ºæ¨¡å¼
```go
// æ‰‡å‡º - ä¸€ä¸ªè¾“å…¥åˆ†å‘åˆ°å¤šä¸ªworker
func fanOut(in <-chan int, workers int) []<-chan int {
    outs := make([]<-chan int, workers)
    for i := 0; i < workers; i++ {
        out := make(chan int)
        outs[i] = out
        
        go func(out chan<- int) {
            defer close(out)
            for val := range in {
                out <- process(val)
            }
        }(out)
    }
    return outs
}

// æ‰‡å…¥ - å¤šä¸ªè¾“å…¥åˆå¹¶åˆ°ä¸€ä¸ªè¾“å‡º
func fanIn(ins ...<-chan int) <-chan int {
    out := make(chan int)
    var wg sync.WaitGroup
    
    for _, in := range ins {
        wg.Add(1)
        go func(in <-chan int) {
            defer wg.Done()
            for val := range in {
                out <- val
            }
        }(in)
    }
    
    go func() {
        wg.Wait()
        close(out)
    }()
    
    return out
}
```

#### è¶…æ—¶æ§åˆ¶æ¨¡å¼
```go
func timeoutOperation(timeout time.Duration) error {
    done := make(chan error, 1)
    
    go func() {
        // æ‰§è¡Œè€—æ—¶æ“ä½œ
        done <- longRunningOperation()
    }()
    
    select {
    case err := <-done:
        return err
    case <-time.After(timeout):
        return errors.New("æ“ä½œè¶…æ—¶")
    }
}
```

