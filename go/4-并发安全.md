# 4. 并发安全

### 🔑 Go `sync.Mutex` 的实现原理

Go 的 `sync.Mutex` 本质是一个基于 **CAS + 自旋 + 信号量** 的混合锁，核心目标是 **减少系统调用**、**提高并发性能**。

#### 内部结构

在 Go 源码里（`runtime2.go`），`Mutex` 大致定义如下：

```go
type Mutex struct {
    state int32  // 锁的状态
    sema  uint32 // 信号量，用于挂起/唤醒
}
```

#### state 的含义

* `0`：未加锁
* `1`：加锁（无其他等待者）
* `>1`：加锁 + 等待队列存在

#### 加锁过程 (`Lock`)

1. **CAS 尝试加锁**：用 `CAS` 将 `state` 从 `0` 改为 `1`，成功则直接获得锁。
2. **自旋等待**：如果失败，尝试在多核 CPU 上 **短暂自旋**（空转几次，可能锁很快释放）。
3. **挂起等待**：如果自旋后还是没抢到，则把自己放入等待队列，并调用 `semacquire` 让 goroutine 进入休眠（避免浪费 CPU）。
4. **被唤醒**：当持有锁的 goroutine 调用 `Unlock` 时，会通过 `semrelease` 唤醒等待队列里的一个 goroutine。

#### 解锁过程 (`Unlock`)

1. **CAS 释放锁**：将 `state` 设为 0。
2. **唤醒等待者**：如果 `state` > 1，说明有等待者，会调用 `semrelease` 唤醒一个 goroutine。

---

### 🔑 Go `sync.RWMutex` 的实现原理

`RWMutex` 是读写分离的锁，允许多个读者并发访问，但写者独占。

#### 内部结构（简化版）

```go
type RWMutex struct {
    w           Mutex  // 写锁，保证写操作互斥
    writerSem   uint32 // 写等待者的信号量
    readerSem   uint32 // 读等待者的信号量
    readerCount int32  // 当前正在持有读锁的 goroutine 数量
    readerWait  int32  // 等待写锁的 goroutine 需要等待的读锁数量
}
```

#### 读锁 (`RLock`)

1. `readerCount++`：如果结果 ≥0，说明没有写锁，直接获取读锁。
2. 如果 `readerCount < 0`，说明有写者在等待，则当前读者需要阻塞在 `readerSem` 上。

#### 写锁 (`Lock`)

1. 先通过 `w.Lock()` 抢到互斥锁，保证只有一个写者进入临界区。
2. 将 `readerCount` 减去一个很大的数（通常是 `-rwmutexMaxReaders`），标记写锁等待中。
3. 如果此时 `readerCount != 0`，说明还有读者持有锁，写者会阻塞在 `writerSem` 上，直到读者释放。

#### 解锁

* `RUnlock`：`readerCount--`，如果最后一个读者释放时发现有写者在等，就唤醒写者。
* `Unlock`：释放写锁后，恢复 `readerCount`，并唤醒所有被阻塞的读者。

---

### 🔑 公平性和性能权衡

* **Mutex**

  * Go 的 `sync.Mutex` 并不是严格公平锁（不是 FIFO 队列）。
  * 它在短暂自旋时，可能让后来的 goroutine 抢到锁 → **牺牲公平性换取性能**。
* **RWMutex**

  * 默认是 **写者优先**，避免写者长期饥饿。
  * 写者来了会阻塞后续读者（`readerCount < 0` 的机制）。

---

### 🔑 内存屏障的作用

* Go 在 `atomic` 和 `lock/unlock` 操作中，会插入 **内存屏障（memory fence）**，保证可见性：

  * **Lock** → 不能把锁内的写操作重排到外面。
  * **Unlock** → 不能把锁内的写操作延迟到锁释放之后。
  * 确保 **happens-before** 关系。

---

| 特性        | 底层组成                      | 核心机制                      |
| --------- | ------------------------- | ------------------------- |
| Goroutine | G结构体 + 栈 + 调度上下文          | M-P-G 调度 + gopark/goready |
| Mutex     | CAS + 信号量                 | 自旋 + 阻塞/唤醒                |
| Channel   | Lock + 环形队列 + send/recv队列 | 阻塞/唤醒 + 数据传递              |
| Once      | Mutex + 原子标记              | 内存屏障 + 快速检查               |
| Timer     | MinHeap + M               | gopark/goready + 定时唤醒     |
| WaitGroup | Atomic计数 + 阻塞队列           | gopark/goready            |


| Go 原语              | 底层机制                       | 阻塞/唤醒            |
| ------------------ | -------------------------- | ---------------- |
| Mutex              | CAS + 自旋 + 信号量             | gopark / goready |
| RWMutex            | CAS + 信号量 + 读写计数           | gopark / goready |
| Channel            | Lock + 环形队列 + send/recv 队列 | gopark / goready |
| Once               | Mutex + atomic + 内存屏障      | gopark / goready |
| WaitGroup          | Atomic 计数 + 阻塞队列           | gopark / goready |
| Timer / Time.Sleep | MinHeap + M                | gopark / goready |


| 特性    | Java AQS                                   | Go runtime                                   |
| ----- | ------------------------------------------ | -------------------------------------------- |
| state | int 原子计数                                   | atomic int / CAS                             |
| 阻塞队列  | CLH 队列                                     | 阻塞 goroutine 链表 / channel queue              |
| 阻塞/唤醒 | LockSupport.park/unpark                    | gopark / goready                             |
| 高级同步  | ReentrantLock / Semaphore / CountDownLatch | Mutex / RWMutex / Channel / WaitGroup / Once |
| 模板机制  | 提供统一模板，用户继承                                | 没有统一模板，但 runtime 提供原语，组合即可                   |


---

### 1. **Goroutine 的状态（G.status）**

在 Go runtime 中，每个 Goroutine 都用一个 `G` 结构体表示，核心字段之一是 `status`，常见状态包括：

| 状态          | 描述                              |
| ----------- | ------------------------------- |
| `Gidle`     | 空闲，不在任何队列中                      |
| `Grunnable` | 可运行，排在 P 的 runqueue 中，等待 M 调度   |
| `Grunning`  | 正在运行（被 M 执行）                    |
| `Gwaiting`  | 阻塞等待某个事件（channel、Mutex、Timer 等） |
| `Gsyscall`  | 正在执行系统调用（阻塞在内核线程）               |
| `Gdead`     | 执行完成或被回收                        |

---

### 2. **状态扭转（State Transitions）**

Goroutine 的状态会根据调度和同步原语不断切换，主要流程：

#### （1）创建

```go
go f()
```

* runtime 分配 G，初始状态：

  ```
  Gidle → Grunnable
  ```
* 放入某个 P 的 local runqueue 或全局队列。

#### （2）调度运行

* 调度器选择 G 执行：

  ```
  Grunnable → Grunning
  ```
* 当前 M 执行该 G 的代码。

#### （3）阻塞等待

* 调用同步原语（Mutex、Channel、WaitGroup、Timer 等）阻塞：

  ```
  Grunning → Gwaiting
  ```
* 底层通过 `gopark()` 实现，G 被挂起，等待事件。

#### （4）唤醒可运行

* 条件满足（Unlock / send / receive / Done / Timer 到期）：

  ```
  Gwaiting → Grunnable
  ```
* 放回 P 的 runqueue，等待 M 调度执行。

#### （5）执行完成

* Goroutine 执行完函数：

  ```
  Grunning → Gdead
  ```
* runtime 可以回收栈和 G 结构体。

---

### 3. **状态扭转图（简化版）**

```
Gidle → Grunnable → Grunning → Gwaiting → Grunnable → Grunning → Gdead
                     ↘--------------------↗
```

* **循环部分**：阻塞/唤醒多次。
* **一次性终止**：执行完成进入 Gdead。

---

### 4. **状态扭转与同步原语的关系**

| 同步原语            | 状态变化                            |
| --------------- | ------------------------------- |
| Mutex / RWMutex | Grunning → Gwaiting → Grunnable |
| Channel         | Grunning → Gwaiting → Grunnable |
| WaitGroup       | Grunning → Gwaiting → Grunnable |
| Timer / Sleep   | Grunning → Gwaiting → Grunnable |

💡 核心思想：**阻塞不消耗线程，唤醒由调度器管理**，轻量高效。

---

