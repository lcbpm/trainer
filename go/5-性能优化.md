# 5. æ€§èƒ½ä¼˜åŒ–

## ğŸ“‹ ç›®å½•

- [5.1 ç¼–è¯‘ä¼˜åŒ–](#51-ç¼–è¯‘ä¼˜åŒ–)
- [5.2 ä»£ç ä¼˜åŒ–](#52-ä»£ç ä¼˜åŒ–)
- [5.3 æ€§èƒ½åˆ†æå®æˆ˜](#53-æ€§èƒ½åˆ†æå®æˆ˜)
- [5.4 ç½‘ç»œç¼–ç¨‹ä¼˜åŒ–](#54-ç½‘ç»œç¼–ç¨‹ä¼˜åŒ–)
- [5.5 æ€§èƒ½ä¼˜åŒ–æœ€ä½³å®è·µ](#55-æ€§èƒ½ä¼˜åŒ–æœ€ä½³å®è·µ)

---

### 5.1 ç¼–è¯‘ä¼˜åŒ–
**Q: Goç¼–è¯‘å™¨çš„ä¼˜åŒ–ç­–ç•¥ï¼Ÿ**
- å†…è”ä¼˜åŒ–
- é€ƒé€¸åˆ†æ
- æ­»ä»£ç æ¶ˆé™¤
- å¸¸é‡ä¼ æ’­
- å¾ªç¯ä¼˜åŒ–

**Q: å¦‚ä½•è¿›è¡Œæ€§èƒ½åˆ†æï¼Ÿ**
- pprofå·¥å…·ä½¿ç”¨
- CPUå’Œå†…å­˜profile
- traceåˆ†æ

#### 5.1.1 ç¼–è¯‘å™¨ä¼˜åŒ–é€‰é¡¹

**ç¼–è¯‘æ ‡ç­¾å’Œä¼˜åŒ–å‚æ•°ï¼š**
```bash
# ç¦ç”¨ä¼˜åŒ–å’Œå†…è”ï¼ˆè°ƒè¯•æ—¶ä½¿ç”¨ï¼‰
go build -gcflags="-N -l"

# å¯ç”¨æ•°æ®ç«äº‰æ£€æµ‹
go run -race main.go

# ç¼–è¯‘ä¼˜åŒ–çº§åˆ«
go build -ldflags="-s -w"  # å»é™¤ç¬¦å·è¡¨å’Œè°ƒè¯•ä¿¡æ¯

# æ€§èƒ½åˆ†æç¼–è¯‘é€‰é¡¹
go build -gcflags="all=-N -l" -o app
```

**ç¼–è¯‘å™¨ä¼˜åŒ–ç¤ºä¾‹ï¼š**
```go
// å†…è”ä¼˜åŒ–ç¤ºä¾‹
func add(a, b int) int {
    return a + b
}

func main() {
    // ç®€å•å‡½æ•°ä¼šè¢«å†…è”
    result := add(1, 2)
    fmt.Println(result)
}

// é€ƒé€¸åˆ†æç¤ºä¾‹
func noEscape() {
    var x int     // xåˆ†é…åœ¨æ ˆä¸Š
    y := &x       // yä¹Ÿåˆ†é…åœ¨æ ˆä¸Šï¼ˆé€ƒé€¸åˆ†æä¼˜åŒ–ï¼‰
    *y = 42
    fmt.Println(x)
}

func escape() *int {
    var x int
    return &x     // xé€ƒé€¸åˆ°å †ä¸Š
}
```

#### 5.1.2 æ€§èƒ½åˆ†æå·¥å…·è¯¦è§£

**pprofé«˜çº§ä½¿ç”¨ï¼š**
```go
// è‡ªå®šä¹‰profile
var cpuProfile = profile.New("cpu")

func customProfile() {
    // å¼€å§‹è‡ªå®šä¹‰profile
    cpuProfile.Start()
    defer cpuProfile.Stop()
    
    // æ‰§è¡Œéœ€è¦åˆ†æçš„ä»£ç 
    heavyWork()
}

// å†…å­˜åˆ†é…åˆ†æ
func memoryAllocationProfile() {
    // åˆ†æç‰¹å®šä»£ç å—çš„å†…å­˜åˆ†é…
    before := runtime.MemStats{}
    after := runtime.MemStats{}
    
    runtime.ReadMemStats(&before)
    
    // æ‰§è¡Œä»£ç 
    processData()
    
    runtime.ReadMemStats(&after)
    
    fmt.Printf("Allocated: %d bytes\n", after.TotalAlloc-before.TotalAlloc)
    fmt.Printf("Mallocs: %d\n", after.Mallocs-before.Mallocs)
}
```

#### Goæ€§èƒ½ä¼˜åŒ–å®æˆ˜æŒ‡å—

**å…¨é¢çš„æ€§èƒ½åˆ†æå’Œä¼˜åŒ–æ¡†æ¶ï¼š**
```go
package main

import (
    "bytes"
    "fmt"
    "log"
    "net/http"
    _ "net/http/pprof"
    "os"
    "runtime"
    "runtime/pprof"
    "runtime/trace"
    "strings"
    "sync"
    "testing"
    "time"
)

// æ€§èƒ½æµ‹è¯•æ•°æ®ç»“æ„
type PerformanceTestData struct {
    Size     int
    Duration time.Duration
    Memory   uint64
    Allocs   uint64
}

// æ€§èƒ½æµ‹è¯•å™¨
type PerformanceTester struct {
    results []PerformanceTestData
    mu      sync.Mutex
}

func NewPerformanceTester() *PerformanceTester {
    return &PerformanceTester{
        results: make([]PerformanceTestData, 0),
    }
}

func (pt *PerformanceTester) Test(name string, size int, testFunc func()) {
    var m1, m2 runtime.MemStats
    runtime.GC()
    runtime.ReadMemStats(&m1)
    
    start := time.Now()
    testFunc()
    duration := time.Since(start)
    
    runtime.ReadMemStats(&m2)
    
    result := PerformanceTestData{
        Size:     size,
        Duration: duration,
        Memory:   m2.HeapAlloc - m1.HeapAlloc,
        Allocs:   m2.Mallocs - m1.Mallocs,
    }
    
    pt.mu.Lock()
    pt.results = append(pt.results, result)
    pt.mu.Unlock()
    
    fmt.Printf("%s (size=%d): %v, memory=%d bytes, allocs=%d\n", 
        name, size, duration, result.Memory, result.Allocs)
}

// å­—ç¬¦ä¸²æ‹¼æ¥æ€§èƒ½å¯¹æ¯”
func stringConcatenationBenchmark(pt *PerformanceTester) {
    fmt.Println("\n=== å­—ç¬¦ä¸²æ‹¼æ¥æ€§èƒ½å¯¹æ¯” ===")
    
    sizes := []int{100, 1000, 10000}
    
    for _, size := range sizes {
        // æ–¹æ³•1ï¼šä½¿ç”¨+æ“ä½œç¬¦
        pt.Test("String+", size, func() {
            result := ""
            for i := 0; i < size; i++ {
                result += "a"
            }
        })
        
        // æ–¹æ³•2ï¼šä½¿ç”¨strings.Builder
        pt.Test("strings.Builder", size, func() {
            var builder strings.Builder
            builder.Grow(size) // é¢„åˆ†é…å®¹é‡
            for i := 0; i < size; i++ {
                builder.WriteString("a")
            }
            _ = builder.String()
        })
        
        // æ–¹æ³•3ï¼šä½¿ç”¨bytes.Buffer
        pt.Test("bytes.Buffer", size, func() {
            var buffer bytes.Buffer
            buffer.Grow(size) // é¢„åˆ†é…å®¹é‡
            for i := 0; i < size; i++ {
                buffer.WriteString("a")
            }
            _ = buffer.String()
        })
    }
}

// Sliceæ“ä½œæ€§èƒ½å¯¹æ¯”
func sliceOperationBenchmark(pt *PerformanceTester) {
    fmt.Println("\n=== Sliceæ“ä½œæ€§èƒ½å¯¹æ¯” ===")
    
    sizes := []int{1000, 10000, 100000}
    
    for _, size := range sizes {
        // æ–¹æ³•1ï¼šæ²¡æœ‰é¢„åˆ†é…
        pt.Test("slice-no-prealloc", size, func() {
            var slice []int
            for i := 0; i < size; i++ {
                slice = append(slice, i)
            }
        })
        
        // æ–¹æ³•2ï¼šé¢„åˆ†é…å®¹é‡
        pt.Test("slice-prealloc", size, func() {
            slice := make([]int, 0, size)
            for i := 0; i < size; i++ {
                slice = append(slice, i)
            }
        })
        
        // æ–¹æ³•3ï¼šç›´æ¥åˆ†é…å¹¶è®¿é—®
        pt.Test("slice-direct", size, func() {
            slice := make([]int, size)
            for i := 0; i < size; i++ {
                slice[i] = i
            }
        })
    }
}

// Mapæ“ä½œæ€§èƒ½å¯¹æ¯”
func mapOperationBenchmark(pt *PerformanceTester) {
    fmt.Println("\n=== Mapæ“ä½œæ€§èƒ½å¯¹æ¯” ===")
    
    sizes := []int{1000, 10000, 100000}
    
    for _, size := range sizes {
        // æ–¹æ³•1ï¼šæ™®é€šmap
        pt.Test("map-normal", size, func() {
            m := make(map[int]int)
            for i := 0; i < size; i++ {
                m[i] = i * 2
            }
        })
        
        // æ–¹æ³•2ï¼šé¢„åˆ†é…å®¹é‡çš„map
        pt.Test("map-prealloc", size, func() {
            m := make(map[int]int, size)
            for i := 0; i < size; i++ {
                m[i] = i * 2
            }
        })
        
        // æ–¹æ³•3ï¼šä½¿ç”¨sync.Mapï¼ˆé«˜å¹¶å‘åœºæ™¯ï¼‰
        pt.Test("sync.Map", size, func() {
            var m sync.Map
            for i := 0; i < size; i++ {
                m.Store(i, i*2)
            }
        })
    }
}

// CPUå¯†é›†å‹ä»»åŠ¡æ€§èƒ½æµ‹è¯•
func cpuIntensiveBenchmark(pt *PerformanceTester) {
    fmt.Println("\n=== CPUå¯†é›†å‹ä»»åŠ¡æ€§èƒ½æµ‹è¯• ===")
    
    // æ•°å­¦è®¡ç®—ä»»åŠ¡
    pt.Test("fibonacci-recursive", 35, func() {
        fibonacci(35)
    })
    
    pt.Test("fibonacci-iterative", 35, func() {
        fibonacciIterative(35)
    })
    
    // å¹¶å‘ä»»åŠ¡
    pt.Test("parallel-computation", 1000000, func() {
        parallelSum(1000000)
    })
}

// é€’å½’æ–æ³¢é‚£å¥‘æ•°åˆ—
func fibonacci(n int) int {
    if n <= 1 {
        return n
    }
    return fibonacci(n-1) + fibonacci(n-2)
}

// è¿­ä»£æ–æ³¢é‚£å¥‘æ•°åˆ—
func fibonacciIterative(n int) int {
    if n <= 1 {
        return n
    }
    a, b := 0, 1
    for i := 2; i <= n; i++ {
        a, b = b, a+b
    }
    return b
}

// å¹¶è¡Œè®¡ç®—æ±‚å’Œ
func parallelSum(n int) int {
    numWorkers := runtime.NumCPU()
    chunkSize := n / numWorkers
    
    results := make(chan int, numWorkers)
    
    for i := 0; i < numWorkers; i++ {
        start := i * chunkSize
        end := start + chunkSize
        if i == numWorkers-1 {
            end = n
        }
        
        go func(start, end int) {
            sum := 0
            for j := start; j < end; j++ {
                sum += j
            }
            results <- sum
        }(start, end)
    }
    
    total := 0
    for i := 0; i < numWorkers; i++ {
        total += <-results
    }
    
    return total
}

// å¯åŠ¨pprofæœåŠ¡å™¨
func startPprofServer() {
    go func() {
        fmt.Println("å¯åŠ¨pprofæœåŠ¡å™¨: http://localhost:6060/debug/pprof/")
        log.Println(http.ListenAndServe("localhost:6060", nil))
    }()
}

// CPU profileåˆ†æ
func runCPUProfile() {
    fmt.Println("\n=== CPU Profileåˆ†æ ===")
    
    // åˆ›å»ºCPU profileæ–‡ä»¶
    f, err := os.Create("cpu.prof")
    if err != nil {
        log.Fatal(err)
    }
    defer f.Close()
    
    // å¼€å§‹CPU profiling
    if err := pprof.StartCPUProfile(f); err != nil {
        log.Fatal(err)
    }
    defer pprof.StopCPUProfile()
    
    // æ‰§è¡Œä¸€äº›CPUå¯†é›†å‹ä»»åŠ¡
    for i := 0; i < 1000000; i++ {
        fibonacci(20)
    }
    
    fmt.Println("CPU profileå·²ä¿å­˜åˆ° cpu.prof")
    fmt.Println("ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤åˆ†æ:")
    fmt.Println("go tool pprof cpu.prof")
}

// Memory profileåˆ†æ
func runMemoryProfile() {
    fmt.Println("\n=== Memory Profileåˆ†æ ===")
    
    // æ‰§è¡Œä¸€äº›å†…å­˜å¯†é›†å‹ä»»åŠ¡
    var data [][]byte
    for i := 0; i < 1000; i++ {
        data = append(data, make([]byte, 1024*1024)) // 1MB
    }
    
    // åˆ›å»ºmemory profileæ–‡ä»¶
    f, err := os.Create("mem.prof")
    if err != nil {
        log.Fatal(err)
    }
    defer f.Close()
    
    runtime.GC() // å¼ºåˆ¶æ‰§è¡ŒGCä»¥è·å¾—å‡†ç¡®çš„å†…å­˜æ•°æ®
    if err := pprof.WriteHeapProfile(f); err != nil {
        log.Fatal(err)
    }
    
    fmt.Println("Memory profileå·²ä¿å­˜åˆ° mem.prof")
    fmt.Println("ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤åˆ†æ:")
    fmt.Println("go tool pprof mem.prof")
    
    _ = data // é˜²æ­¢ç¼–è¯‘å™¨ä¼˜åŒ–
}

// Traceåˆ†æ
func runTraceAnalysis() {
    fmt.Println("\n=== Traceåˆ†æ ===")
    
    // åˆ›å»ºtraceæ–‡ä»¶
    f, err := os.Create("trace.out")
    if err != nil {
        log.Fatal(err)
    }
    defer f.Close()
    
    // å¼€å§‹è·Ÿè¸ª
    if err := trace.Start(f); err != nil {
        log.Fatal(err)
    }
    defer trace.Stop()
    
    // æ‰§è¡Œä¸€äº›å¹¶å‘ä»»åŠ¡
    var wg sync.WaitGroup
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            for j := 0; j < 100000; j++ {
                _ = fibonacciIterative(20)
            }
        }(i)
    }
    wg.Wait()
    
    fmt.Println("Traceæ•°æ®å·²ä¿å­˜åˆ° trace.out")
    fmt.Println("ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤åˆ†æ:")
    fmt.Println("go tool trace trace.out")
}

### 5.2 ä»£ç ä¼˜åŒ–

#### 5.2.1 å­—ç¬¦ä¸²ä¼˜åŒ–
**Q: å­—ç¬¦ä¸²æ‹¼æ¥çš„æ€§èƒ½æ¯”è¾ƒï¼Ÿ**
- + æ“ä½œç¬¦ vs fmt.Sprintf vs strings.Builder

**å­—ç¬¦ä¸²ä¼˜åŒ–æœ€ä½³å®è·µï¼š**
1. å¤§é‡å­—ç¬¦ä¸²æ‹¼æ¥ä½¿ç”¨ strings.Builder
2. é¢„åˆ†é…å®¹é‡é¿å…å¤šæ¬¡å†…å­˜åˆ†é…
3. é¿å…åœ¨å¾ªç¯ä¸­ä½¿ç”¨ + æ“ä½œç¬¦æ‹¼æ¥å­—ç¬¦ä¸²

#### 5.2.2 å†…å­˜ä¼˜åŒ–
**Q: å¦‚ä½•å‡å°‘å†…å­˜åˆ†é…ï¼Ÿ**
- å¯¹è±¡å¤ç”¨
- ä½¿ç”¨å¯¹è±¡æ±  sync.Pool
- é¢„åˆ†é…åˆ‡ç‰‡å’Œæ˜ å°„å®¹é‡


// å¯¹è±¡æ± ä½¿ç”¨ç¤ºä¾‹
var bufferPool = sync.Pool{
    New: func() interface{} {
        return new(bytes.Buffer)
    },
}

func processWithPool() {
    // ä»æ± ä¸­è·å–å¯¹è±¡
    buf := bufferPool.Get().(*bytes.Buffer)
    defer func() {
        // æ¸…ç©ºå¹¶å½’è¿˜åˆ°æ± ä¸­
        buf.Reset()
        bufferPool.Put(buf)
    }()
    
    // ä½¿ç”¨buffer
    buf.WriteString("Hello, World!")
    fmt.Println(buf.String())
}

// é¿å…é€ƒé€¸åˆ†æé—®é¢˜
func avoidEscape() {
    // åœ¨æ ˆä¸Šåˆ†é…
    var arr [1000]int
    for i := range arr {
        arr[i] = i
    }
    // å¤„ç†æ•°ç»„...
    
    // å¦‚æœè¿”å›æŒ‡é’ˆåˆ™ä¼šé€ƒé€¸åˆ°å †ä¸Š
    // return &arr  // è¿™ä¼šå¯¼è‡´é€ƒé€¸
}
```

#### 5.2.3 å¹¶å‘ä¼˜åŒ–
**Q: å¦‚ä½•ä¼˜åŒ–å¹¶å‘æ€§èƒ½ï¼Ÿ**
- å‡å°‘é”ç«äº‰
- ä½¿ç”¨æ— é”æ•°æ®ç»“æ„
- åˆç†ä½¿ç”¨goroutine

```go
// é”ä¼˜åŒ–ç¤ºä¾‹
type OptimizedCounter struct {
    mu    sync.Mutex
    count int64
}

// æ‰¹é‡æ›´æ–°å‡å°‘é”ç«äº‰
func (c *OptimizedCounter) BatchAdd(n int64) {
    c.mu.Lock()
    c.count += n
    c.mu.Unlock()
}

// æ— é”è®¡æ•°å™¨
type AtomicCounter struct {
    count int64
}

func (c *AtomicCounter) Add(n int64) {
    atomic.AddInt64(&c.count, n)
}

func (c *AtomicCounter) Load() int64 {
    return atomic.LoadInt64(&c.count)
}

// Worker Poolæ¨¡å¼
type WorkerPool struct {
    jobs    chan func()
    workers int
}

func NewWorkerPool(workers int) *WorkerPool {
    return &WorkerPool{
        jobs:    make(chan func(), 100),
        workers: workers,
    }
}

func (wp *WorkerPool) Start() {
    for i := 0; i < wp.workers; i++ {
        go func() {
            for job := range wp.jobs {
                job()
            }
        }()
    }
}

func (wp *WorkerPool) Submit(job func()) {
    wp.jobs <- job
}

func (wp *WorkerPool) Stop() {
    close(wp.jobs)
}
```

#### 5.2.4 I/Oä¼˜åŒ–
**Q: å¦‚ä½•ä¼˜åŒ–I/Oæ€§èƒ½ï¼Ÿ**
- ä½¿ç”¨bufioè¿›è¡Œç¼“å†²
- åˆç†è®¾ç½®ç¼“å†²åŒºå¤§å°
- é¿å…é¢‘ç¹çš„å°I/Oæ“ä½œ

```go
// I/Oä¼˜åŒ–ç¤ºä¾‹
func optimizedFileRead(filename string) error {
    file, err := os.Open(filename)
    if err != nil {
        return err
    }
    defer file.Close()
    
    // ä½¿ç”¨bufioå‡å°‘ç³»ç»Ÿè°ƒç”¨
    reader := bufio.NewReader(file)
    
    // è®¾ç½®åˆé€‚çš„ç¼“å†²åŒºå¤§å°
    buf := make([]byte, 32*1024) // 32KBç¼“å†²åŒº
    
    for {
        n, err := reader.Read(buf)
        if err != nil && err != io.EOF {
            return err
        }
        if n == 0 {
            break
        }
        
        // å¤„ç†æ•°æ®
        processData(buf[:n])
    }
    
    return nil
}

// æ‰¹é‡å†™å…¥ä¼˜åŒ–
func optimizedBatchWrite(filename string, data [][]byte) error {
    file, err := os.Create(filename)
    if err != nil {
        return err
    }
    defer file.Close()
    
    // ä½¿ç”¨bufioè¿›è¡Œæ‰¹é‡å†™å…¥
    writer := bufio.NewWriterSize(file, 64*1024) // 64KBå†™ç¼“å†²
    defer writer.Flush()
    
    for _, d := range data {
        if _, err := writer.Write(d); err != nil {
            return err
        }
    }
    
    return nil
}
```

go
func main() {
    // å¯åŠ¨pprofæœåŠ¡å™¨
    startPprofServer()
    
    // ç­‰å¾…æœåŠ¡å™¨å¯åŠ¨
    time.Sleep(1 * time.Second)
    
    // åˆ›å»ºæ€§èƒ½æµ‹è¯•å™¨
    pt := NewPerformanceTester()
    
    // æ‰§è¡Œå„ç§æ€§èƒ½æµ‹è¯•
    stringConcatenationBenchmark(pt)
    sliceOperationBenchmark(pt)
    mapOperationBenchmark(pt)
    cpuIntensiveBenchmark(pt)
    
    // æ‰§è¡Œæ€§èƒ½åˆ†æ
    runCPUProfile()
    runMemoryProfile()
    runTraceAnalysis()
    
    fmt.Println("\næ€§èƒ½åˆ†æå®Œæˆï¼")
    fmt.Println("è®¿é—® http://localhost:6060/debug/pprof/ æŸ¥çœ‹å®æ—¶æ€§èƒ½æ•°æ®")
    
    // ä¿æŒç¨‹åºè¿è¡Œä»¥ä¾¿æŸ¥çœ‹pprof
    select {}
}
```

### 5.3 æ€§èƒ½åˆ†æå®æˆ˜

#### pprof ä½¿ç”¨ç¤ºä¾‹
```go
import (
    _ "net/http/pprof"
    "net/http"
    "log"
)

func main() {
    // å¯åŠ¨pprofæœåŠ¡
    go func() {
        log.Println(http.ListenAndServe("localhost:6060", nil))
    }()
    
    // ä¸»ç¨‹åºé€»è¾‘
    runApplication()
}
```

#### åŸºå‡†æµ‹è¯•ç¼–å†™
```go
func BenchmarkSliceAppend(b *testing.B) {
    b.Run("WithoutPrealloc", func(b *testing.B) {
        for i := 0; i < b.N; i++ {
            var slice []int
            for j := 0; j < 1000; j++ {
                slice = append(slice, j)
            }
        }
    })
    
    b.Run("WithPrealloc", func(b *testing.B) {
        for i := 0; i < b.N; i++ {
            slice := make([]int, 0, 1000)
            for j := 0; j < 1000; j++ {
                slice = append(slice, j)
            }
        }
    })
}
```


### 5.4 ç½‘ç»œç¼–ç¨‹ä¼˜åŒ–

#### 5.4.1 HTTPå®¢æˆ·ç«¯ä¼˜åŒ–

**è¿æ¥æ± å’Œå¤ç”¨ï¼š**
```go
// è‡ªå®šä¹‰HTTPå®¢æˆ·ç«¯ä¼˜åŒ–
func createOptimizedHTTPClient() *http.Client {
    // åˆ›å»ºå¸¦è¿æ¥æ± çš„ä¼ è¾“å±‚
    transport := &http.Transport{
        MaxIdleConns:        100,              // æœ€å¤§ç©ºé—²è¿æ¥æ•°
        MaxIdleConnsPerHost: 10,               // æ¯ä¸ªä¸»æœºæœ€å¤§ç©ºé—²è¿æ¥æ•°
        IdleConnTimeout:     90 * time.Second, // ç©ºé—²è¿æ¥è¶…æ—¶æ—¶é—´
        TLSHandshakeTimeout: 10 * time.Second, // TLSæ¡æ‰‹è¶…æ—¶æ—¶é—´
        DisableKeepAlives:   false,            // å¯ç”¨Keep-Alive
    }
    
    return &http.Client{
        Transport: transport,
        Timeout:   30 * time.Second, // è¯·æ±‚è¶…æ—¶æ—¶é—´
    }
}

// éœ€è¦å¯¼å…¥: "net/http", "time"

// å¹¶å‘å®‰å…¨çš„HTTPå®¢æˆ·ç«¯
var httpClient = createOptimizedHTTPClient()

func makeConcurrentRequests(urls []string) {
    var wg sync.WaitGroup
    results := make(chan string, len(urls))
    
    for _, url := range urls {
        wg.Add(1)
        go func(u string) {
            defer wg.Done()
            
            resp, err := httpClient.Get(u)
            if err != nil {
                results <- fmt.Sprintf("Error: %v", err)
                return
            }
            defer resp.Body.Close()
            
            body, _ := io.ReadAll(resp.Body)
            results <- string(body)
        }(url)
    }
    
    wg.Wait()
    close(results)
    
    // å¤„ç†ç»“æœ
    for result := range results {
        fmt.Println(result)
    }
}
```

#### 5.4.2 HTTPæœåŠ¡ç«¯ä¼˜åŒ–

**ä¸­é—´ä»¶å’Œæ€§èƒ½ä¼˜åŒ–ï¼š**
```go
// é™æµä¸­é—´ä»¶
func rateLimitMiddleware(next http.HandlerFunc) http.HandlerFunc {
    // ä½¿ç”¨ä»¤ç‰Œæ¡¶ç®—æ³•
    limiter := rate.NewLimiter(rate.Every(time.Second), 100) // æ¯ç§’100ä¸ªè¯·æ±‚
    
    return func(w http.ResponseWriter, r *http.Request) {
        if !limiter.Allow() {
            http.Error(w, "Too Many Requests", http.StatusTooManyRequests)
            return
        }
        next(w, r)
    }
}

// éœ€è¦å¯¼å…¥: "net/http", "time", "golang.org/x/time/rate"

// å‹ç¼©ä¸­é—´ä»¶
func compressionMiddleware(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        // æ£€æŸ¥å®¢æˆ·ç«¯æ˜¯å¦æ”¯æŒå‹ç¼©
        if strings.Contains(r.Header.Get("Accept-Encoding"), "gzip") {
            gz := gzip.NewWriter(w)
            defer gz.Close()
            
            // åˆ›å»ºå‹ç¼©å“åº”å†™å…¥å™¨
            gw := &gzipResponseWriter{Writer: gz, ResponseWriter: w}
            next(gw, r)
            return
        }
        next(w, r)
    }
}

// éœ€è¦å¯¼å…¥: "net/http", "strings", "compress/gzip"

// GZIPå“åº”å†™å…¥å™¨
type gzipResponseWriter struct {
    io.Writer
    http.ResponseWriter
}

func (w *gzipResponseWriter) Write(b []byte) (int, error) {
    return w.Writer.Write(b)
}

// ç¼“å­˜ä¸­é—´ä»¶
func cacheMiddleware(next http.HandlerFunc) http.HandlerFunc {
    cache := make(map[string][]byte)
    var mu sync.RWMutex
    
    return func(w http.ResponseWriter, r *http.Request) {
        // å°è¯•ä»ç¼“å­˜è·å–
        mu.RLock()
        if cached, ok := cache[r.URL.Path]; ok {
            mu.RUnlock()
            w.Header().Set("Content-Type", "application/json")
            w.Write(cached)
            return
        }
        mu.RUnlock()
        
        // æ‰§è¡ŒåŸå§‹å¤„ç†å‡½æ•°å¹¶ç¼“å­˜ç»“æœ
        // æ³¨æ„ï¼šè¿™æ˜¯ä¸€ä¸ªç®€åŒ–çš„ç¤ºä¾‹ï¼Œå®é™…åº”ç”¨ä¸­éœ€è¦æ›´å¤æ‚çš„ç¼“å­˜ç­–ç•¥
        next(w, r)
    }
}
```

#### 5.4.3 TCPè¿æ¥ä¼˜åŒ–

**é•¿è¿æ¥å’Œè¿æ¥æ± ï¼š**
```go
// TCPè¿æ¥æ± 
type TCPConnectionPool struct {
    mu       sync.Mutex
    pool     chan net.Conn
    factory  func() (net.Conn, error)
    capacity int
}

func NewTCPConnectionPool(factory func() (net.Conn, error), capacity int) *TCPConnectionPool {
    return &TCPConnectionPool{
        pool:     make(chan net.Conn, capacity),
        factory:  factory,
        capacity: capacity,
    }
}

func (p *TCPConnectionPool) Get() (net.Conn, error) {
    select {
    case conn := <-p.pool:
        // æ£€æŸ¥è¿æ¥æ˜¯å¦ä»ç„¶æœ‰æ•ˆ
        if conn != nil {
            return conn, nil
        }
    default:
        // åˆ›å»ºæ–°è¿æ¥
        return p.factory()
    }
    return nil, errors.New("connection pool error")
}

func (p *TCPConnectionPool) Put(conn net.Conn) {
    p.mu.Lock()
    defer p.mu.Unlock()
    
    select {
    case p.pool <- conn:
    default:
        // è¿æ¥æ± å·²æ»¡ï¼Œå…³é—­è¿æ¥
        conn.Close()
    }
}

// éœ€è¦å¯¼å…¥: "net", "sync", "errors"

// ä½¿ç”¨è¿æ¥æ± çš„ç¤ºä¾‹
func useConnectionPool() {
    pool := NewTCPConnectionPool(func() (net.Conn, error) {
        return net.DialTimeout("tcp", "example.com:80", 5*time.Second)
    }, 10)
    
    conn, err := pool.Get()
    if err != nil {
        log.Printf("Failed to get connection: %v", err)
        return
    }
    defer pool.Put(conn)
    
    // ä½¿ç”¨è¿æ¥
    fmt.Fprintf(conn, "GET / HTTP/1.1\r\nHost: example.com\r\n\r\n")
    // ... å¤„ç†å“åº”
}
```

#### 5.4.4 WebSocketä¼˜åŒ–

**WebSocketè¿æ¥ç®¡ç†ï¼š**
```go
// WebSocketè¿æ¥ç®¡ç†å™¨
type WebSocketManager struct {
    connections map[*websocket.Conn]bool
    broadcast   chan []byte
    register    chan *websocket.Conn
    unregister  chan *websocket.Conn
    mutex       sync.RWMutex
}

func NewWebSocketManager() *WebSocketManager {
    return &WebSocketManager{
        connections: make(map[*websocket.Conn]bool),
        broadcast:   make(chan []byte),
        register:    make(chan *websocket.Conn),
        unregister:  make(chan *websocket.Conn),
    }
}

func (manager *WebSocketManager) Run() {
    for {
        select {
        case conn := <-manager.register:
            manager.mutex.Lock()
            manager.connections[conn] = true
            manager.mutex.Unlock()
            
        case conn := <-manager.unregister:
            manager.mutex.Lock()
            if _, ok := manager.connections[conn]; ok {
                delete(manager.connections, conn)
                conn.Close()
            }
            manager.mutex.Unlock()
            
        case message := <-manager.broadcast:
            manager.mutex.RLock()
            for conn := range manager.connections {
                // å¼‚æ­¥å‘é€æ¶ˆæ¯ä»¥é¿å…é˜»å¡
                go func(c *websocket.Conn) {
                    err := c.WriteMessage(websocket.TextMessage, message)
                    if err != nil {
                        manager.unregister <- c
                    }
                }(conn)
            }
            manager.mutex.RUnlock()
        }
    }
}

// éœ€è¦å¯¼å…¥: "github.com/gorilla/websocket", "sync"
```

### 5.5 æ€§èƒ½ä¼˜åŒ–æœ€ä½³å®è·µ

#### 5.5.1 é€šç”¨ä¼˜åŒ–åŸåˆ™
1. **å…ˆæµ‹é‡å†ä¼˜åŒ–** - ä½¿ç”¨æ€§èƒ½åˆ†æå·¥å…·æ‰¾å‡ºçœŸæ­£çš„ç“¶é¢ˆ
2. **é¿å…è¿‡æ—©ä¼˜åŒ–** - éµå¾ª"è®©å®ƒå·¥ä½œï¼Œè®©å®ƒæ­£ç¡®ï¼Œè®©å®ƒå¿«é€Ÿ"çš„åŸåˆ™
3. **å…³æ³¨çƒ­ç‚¹è·¯å¾„** - ä¼˜åŒ–æ‰§è¡Œé¢‘ç‡æœ€é«˜çš„ä»£ç 

#### 5.5.2 å†…å­˜ç®¡ç†æœ€ä½³å®è·µ
1. **é‡ç”¨å¯¹è±¡** - ä½¿ç”¨sync.Poolå‡å°‘GCå‹åŠ›
2. **é¢„åˆ†é…å®¹é‡** - ä¸ºsliceå’Œmapé¢„åˆ†é…åˆé€‚çš„å®¹é‡
3. **é¿å…å†…å­˜æ³„æ¼** - åŠæ—¶å…³é—­èµ„æºï¼Œå–æ¶ˆgoroutine

#### 5.5.3 å¹¶å‘ä¼˜åŒ–æœ€ä½³å®è·µ
1. **é™åˆ¶goroutineæ•°é‡** - ä½¿ç”¨worker poolæ§åˆ¶å¹¶å‘æ•°
2. **å‡å°‘é”ç«äº‰** - ä½¿ç”¨æ— é”ç»“æ„æˆ–åˆ†ç‰‡é”
3. **æ‰¹é‡å¤„ç†** - å‡å°‘ä¸Šä¸‹æ–‡åˆ‡æ¢å¼€é”€

#### 5.5.4 I/Oä¼˜åŒ–æœ€ä½³å®è·µ
1. **ä½¿ç”¨ç¼“å†²I/O** - bufioå‡å°‘ç³»ç»Ÿè°ƒç”¨æ¬¡æ•°
2. **å¼‚æ­¥I/O** - é¿å…é˜»å¡ä¸»çº¿ç¨‹
3. **è¿æ¥æ± ** - å¤ç”¨ç½‘ç»œè¿æ¥

#### 5.5.5 ç¼–è¯‘ä¼˜åŒ–å»ºè®®
1. **å¯ç”¨ç¼–è¯‘å™¨ä¼˜åŒ–** - é»˜è®¤æƒ…å†µä¸‹Goç¼–è¯‘å™¨å·²å¯ç”¨ä¼˜åŒ–
2. **ä½¿ç”¨åˆé€‚çš„æ„å»ºæ ‡ç­¾** - æ ¹æ®ç¯å¢ƒä½¿ç”¨ä¸åŒä¼˜åŒ–ç­–ç•¥
3. **å»é™¤è°ƒè¯•ä¿¡æ¯** - ç”Ÿäº§ç¯å¢ƒä½¿ç”¨-ldflags="-s -w"

#### 5.5.6 ç›‘æ§å’ŒæŒç»­ä¼˜åŒ–
1. **å»ºç«‹æ€§èƒ½åŸºçº¿** - å®šæœŸè¿è¡ŒåŸºå‡†æµ‹è¯•
2. **ç›‘æ§å…³é”®æŒ‡æ ‡** - CPUã€å†…å­˜ã€GCé¢‘ç‡ç­‰
3. **è‡ªåŠ¨åŒ–æ€§èƒ½æµ‹è¯•** - å°†æ€§èƒ½æµ‹è¯•é›†æˆåˆ°CI/CDæµç¨‹

## ç³»ç»Ÿæµé‡è¯„ä¼°ä¸æ€§èƒ½æŒ‡æ ‡

### åŸºç¡€æ€§èƒ½è®¡ç®—
- **å•æ ¸å¤„ç†èƒ½åŠ›**ï¼š1ä¸ªè¯·æ±‚è€—æ—¶20ms â†’ 1ç§’å¤„ç†50ä¸ªè¯·æ±‚
- **å¤šæ ¸å¤„ç†èƒ½åŠ›**ï¼š8æ ¸16çº¿ç¨‹ â†’ 16 Ã— 50 = 800è¯·æ±‚/ç§’
- **å®é™…å¯ç”¨æ€§èƒ½**ï¼š800 Ã— 70% = 560è¯·æ±‚/ç§’ï¼ˆè€ƒè™‘ç³»ç»Ÿå¼€é”€ï¼‰

### ç›®æ ‡QPSèŒƒå›´
- **æœ€ä½ç›®æ ‡**ï¼š30,000 QPS
- **æœ€é«˜ç›®æ ‡**ï¼š60,000 QPS

### æ‰©å±•æ€§éœ€æ±‚åˆ†æ
- **3ä¸‡QPSæ‰€éœ€å®ä¾‹æ•°**ï¼š30,000 Ã· 560 â‰ˆ 54å°
- **6ä¸‡QPSæ‰€éœ€å®ä¾‹æ•°**ï¼š60,000 Ã· 560 â‰ˆ 108å°

### æ€§èƒ½ä¼˜åŒ–å»ºè®®
1. **æ°´å¹³æ‰©å±•**ï¼šæ ¹æ®è®¡ç®—ç»“æœéƒ¨ç½²54-108å°æœåŠ¡å™¨å®ä¾‹
2. **è´Ÿè½½å‡è¡¡**ï¼šä½¿ç”¨è´Ÿè½½å‡è¡¡å™¨åˆ†å‘è¯·æ±‚
3. **æ€§èƒ½ç›‘æ§**ï¼šå®æ—¶ç›‘æ§å„å®ä¾‹çš„CPUã€å†…å­˜ä½¿ç”¨ç‡
4. **è‡ªåŠ¨ä¼¸ç¼©**ï¼šåŸºäºç›‘æ§æŒ‡æ ‡å®ç°è‡ªåŠ¨æ‰©ç¼©å®¹


